#' @title PipeOpAmelia_T
#'
#' @name PipeOpAmelia_T
#'
#' @description
#' Implements EMB methods as mlr3 pipeline more about Amelia \code{\link{autotune_Amelia}} or \url{https://cran.r-project.org/web/packages/Amelia/Amelia.pdf}
#'
#' @section Input and Output Channels:
#' Input and output channels are inherited from \code{\link{PipeOpTaskPreproc}}.
#'
#'
#' @section Parameters:
#' The parameters include inherited from [`PipeOpTaskPreproc`], as well as: \cr
#' \itemize{
#' \item \code{id} :: \code{character(1)}\cr
#' Identifier of resulting object, default \code{"imput_Amelia"}.
#' \item \code{m} :: \code{integer(1)}\cr
#' Number of datasets generated by Amelia, default \code{3}.
#' \item \code{polytime} :: \code{integer(1)}\cr
#' Integer between 0 and 3 indicating what power of polynomial should be included in the imputation model to account for the effects of time. A setting of 0 would indicate constant levels, 1 would indicate linear time effects, 2 would indicate squared effects, and 3 would indicate cubic time effects, default \code{NULL}.
#' \item \code{splinetime} :: \code{integer(1)}\cr
#' Integer value of 0 or greater to control cubic smoothing splines of time. Values between 0 and 3 create a simple polynomial of time (identical to the polytime argument). Values k greater than 3 create a spline with an additional k-3 knotpoints, default \code{NULL}.
#' \item \code{intercs} :: \code{logical(1)}\cr
#' Variable indicating if the time effects of polytime should vary across the cross-section, default \code{FALSE}.
#' \item \code{empir} :: \code{double(1)}\cr
#' Number indicating level of the empirical (or ridge) prior. This prior shrinks the covariances of the data, but keeps the means and variances the same for problems of high missingness, small N's or large correlations among the variables. Should be kept small, perhaps 0.5 to 1 percent of the rows of the data; a reasonable upper bound is around 10 percent of the rows of the data. If empir is not set, empir=nrow(df)*0.015, default \code{NULL}.
#' \item \code{parallel} :: \code{double(1)}\cr
#' If true parallel calculation is used, default \code{TRUE}.
#' \item \code{col_0_1} :: \code{logical(1)}\cr
#' Decides whether to add a bonus column informing where values were imputed. 0 - value was in dataset, 1 - value was imputed, default \code{FALSE}.
#' \item \code{out_fill} :: \code{character(1)}\cr
#' Output log file location. If file already exists log message will be added. If NULL no log will be produced, default \code{NULL}.
#'}
#'
#' @export

PipeOpAmelia_T <-  R6::R6Class("Amelia_imputation",lock_objects=FALSE,
                                 inherit = PipeOpTaskPreproc,  # inherit from PipeOp
                                 public = list(
                                   initialize = function(id = "imput_Amelia", col_0_1=FALSE,polytime=NULL,splinetime=NULL,intercs=FALSE,empir=NULL,m=3,parallel=TRUE,out_file=NULL
                                   ) {
                                     super$initialize(id, param_vals = list(col_0_1=col_0_1,polytime=polytime,splinetime=splinetime,intercs=intercs,empir=empir,m=m,parallel=parallel,out_file=out_file),
                                                      param_set= ParamSet$new(list(
                                                        'polytime'=ParamUty$new('polytime', default = NULL, tags = 'amelia'),
                                                        'splinetime'=ParamUty$new('splinetime',default = NULL,tags='amelia'),
                                                        'empir'=ParamUty$new('empir',default = NULL,tags='amelia'),
                                                        'parallel'=ParamLgl$new('parallel',default = TRUE,tags = 'amelia'),
                                                        'intercs'=ParamLgl$new('intercs',default = FALSE,tags='amelia'),
                                                        'col_0_1'=ParamLgl$new('col_0_1',default = F,tags='amelia'),
                                                        'm'=ParamInt$new('m',lower = 1,upper = Inf,default = 3,tags='amelia'),
                                                        'out_file'=ParamUty$new('out_file',default = NULL,tags = 'amelia')





                                                      ))
                                     )





                                   }),private=list(

                                     .train_task=function(task){

                                       data_to_impute <- as.data.frame( task$data(cols = task$feature_names))
                                       targer <- as.data.frame(task$data(cols = task$target_names))
                                       col_type <- 1:ncol(data_to_impute)
                                       for (i in col_type){
                                         col_type[i] <- class(data_to_impute[,i])
                                       }
                                       percent_of_missing <- 1:ncol(data_to_impute)
                                       for (i in percent_of_missing){
                                         percent_of_missing[i] <- (sum(is.na(data_to_impute[,i]))/length(data_to_impute[,1]))*100
                                       }
                                       col_miss <- colnames(data_to_impute)[percent_of_missing>0]
                                       col_no_miss <- colnames(data_to_impute)[percent_of_missing==0]

                                       data_imputed <- autotune_Amelia(data_to_impute,col_type,percent_of_missing,col_0_1 = self$param_set$values$col_0_1,
                                                                       parallel = self$param_set$values$parallel,polytime = self$param_set$values$polytime,
                                                                       splinetime = self$param_set$values$splinetime, intercs = self$param_set$values$intercs,
                                                                       empir = self$param_set$values$empir,m=self$param_set$values$m,
                                                                       out_file=self$param_set$values$out_file)

                                       data_imputed <-  cbind(data_imputed,task$row_ids)
                                       colnames(data_imputed)[ncol(data_imputed)] <- task$backend$primary_key
                                       task$cbind(as.data.table(data_imputed))

                                     },
                                     .predict_task=function(task){
                                       data_to_impute <- as.data.frame( task$data(cols = task$feature_names))
                                       targer <- as.data.frame(task$data(cols = task$target_names))
                                       col_type <- 1:ncol(data_to_impute)
                                       for (i in col_type){
                                         col_type[i] <- class(data_to_impute[,i])
                                       }
                                       percent_of_missing <- 1:ncol(data_to_impute)
                                       for (i in percent_of_missing){
                                         percent_of_missing[i] <- (sum(is.na(data_to_impute[,i]))/length(data_to_impute[,1]))*100
                                       }


                                       col_miss <- colnames(data_to_impute)[percent_of_missing>0]
                                       col_no_miss <- colnames(data_to_impute)[percent_of_missing==0]

                                       data_imputed <- autotune_Amelia(data_to_impute,col_type,percent_of_missing,col_0_1 = self$param_set$values$col_0_1,
                                                                       parallel = self$param_set$values$parallel,polytime = self$param_set$values$polytime,
                                                                       splinetime = self$param_set$values$splinetime, intercs = self$param_set$values$intercs,
                                                                       empir = self$param_set$values$empir,m=self$param_set$values$m,
                                                                       out_file=self$param_set$values$out_file)


                                       data_imputed <-  cbind(data_imputed,task$row_ids)
                                       colnames(data_imputed)[ncol(data_imputed)] <- task$backend$primary_key
                                       task$cbind(as.data.table(data_imputed))





                                     }





                                 )
)

mlr_pipeops$add("Amelia_imputation", PipeOpAmelia_T)

# test_task <- TaskClassif$new('test',df,'binaryClass')
# op <- PipeOpAmelia$new()
# pipe <- op %>>% learner_po
# grln <- GraphLearner$new(pipe)
# pipe$train(test_task)


# graph <- PipeOpAmelia_T$new() %>>% pipe_encoding %>>% pipe_model
# graph_learner <- GraphLearner$new(graph)
# task <- mlr3oml::OMLTask$new(id = id)
# task <- task$task
# #
# #
# d <- resample(task,graph_learner,rsmp("holdout"))
#
# test <- iris
# task$data()

