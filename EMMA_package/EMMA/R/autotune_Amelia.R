#' Perform imputation using Amelia package and EMB algorithm.
#'
#' @description Function use EMB (Expectation-Maximization with Bootstrapping ) to impute missing data. Function performance is highly depend from data structure and
#' chosen parameters.
#'
#'
#' @param df data.frame. Df to impute with column names and without target column.
#' @param col_type character vector. Vector containing column type names.
#' @param percent_of_missing numeric vector. Vector contatining percent of missing data in columns for example  c(0,1,0,0,11.3,..)
#' @param col_0_1 Decaid if add bonus column informing where imputation been done. 0 - value was in dataset, 1 - value was imputed. Default False. (Works only for returning one dataset).
#' @param parallel If true parallel calculation is used.
#' @param polytime parameter pass to amelia function
#' @param splinetime parameter pass to amelia finction
#' @param intercs parameter pass to amleia function
#' @param optimize_empir If set on TRUE function try to choose lowest possible empir for given data (low empir correspond with good imputation). This setting
#' significantly elongate computation time and make function unstable. Should be used only with supervised.
#' @param empir parameter pass to amelia function. If empir dont set and optimize_empir = FALSE empir=nrow(df)*0.015.
#' @param verbose If true function will print on console.
#' @param return_one Decide if one dataset or amelia object will be returned.
#' @param m Number of datasets generated by amelia. If retrun_one=TRUE first dataset will be given.
#' @import Amelia
#'
#' @return Return one data.frame with imputed values or amelia object.



autotune_Amelia <- function(df,col_type,percent_of_missing,col_0_1=FALSE,parallel=TRUE,polytime=NULL,splinetime=NULL,intercs=FALSE,optimize_empir=FALSE,
                            empir=NULL,verbose=FALSE,return_one=TRUE,m=3) {

  if (sum(is.na(df))==0){return(df)}
  # prepering information about categorical column
  categorical_col <-  colnames(df)[ifelse(col_type=='factor',T,F)]
  if(length(categorical_col)==0){categorical_col <- NULL}

  # seting parallel options
  if(parallel){
    parallel <- 'multicore'
  }
  if( 'multicore'!=parallel){
    parallel <- 'no'
  }
  n_row <- length(df[,1])
  if (optimize_empir){
  # Prepering empir set

  empir_set <- seq(n_row*0.005,n_row*0.15,length.out = 11)
  empir_set <- c(0,empir_set)
  # Amelia Run
  for (i in empir_set){
    go_next <- FALSE
    flag <- FALSE
  tryCatch({
    final <- amelia(df,m=m,noms = categorical_col,parallel = parallel,p2s = as.numeric(verbose),empri = i,polytime = polytime,splinetime = splinetime,intercs = intercs)
    if(length(final$imputations$imp1)!=length(df)){
      stop('ERROR')
    }
    else{flag <- TRUE}
    if (return_one){
      final <- final$imputations$imp1
    }


  },error = function(e){
    go_next <- TRUE
    print(e)})
  if(flag){break}
  if(go_next){next}
  }

  }

  if(!optimize_empir){
    if (is.null(empir) ){
      empir <- n_row*0.015
    }
    final <- amelia(df,m=m,noms = categorical_col,parallel = parallel,p2s = as.numeric(verbose),empri = empir,polytime = polytime,splinetime = splinetime,intercs = intercs)
    if (return_one){
      final <- final$imputations$imp1
    }
  }
  if(class(final)!='data.frame' & class(final)!='amelia'){
    stop('ERROR')
  }
  if(col_0_1 & return_one){

      columns_with_missing <-  (as.data.frame(is.na(df))*1)[,percent_of_missing>0]
      colnames(columns_with_missing) <- paste(colnames(columns_with_missing),'where',sep='_')
      final <- cbind(final,columns_with_missing)

  }
  return(final)

}




