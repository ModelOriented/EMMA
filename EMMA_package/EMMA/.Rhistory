if (self$imputed){
feature <- self$data_imputed[,setdiff(colnames(self$data_imputed),colnames(context))]
}
if(nrow(self$data_imputed)!=nrow(context)){
self$imputed_predict <- FALSE
self$flag <- 'predict'
}
if(!self$imputed_predict){
print('predict')
data_to_impute <- cbind(feature,context)
self$data_imputed <- self$imp_function(data_to_impute)
colnames(self$data_imputed) <- self$state$context_cols
self$imputed_predict <- TRUE
}
if (self$imputed_predict & self$flag=='predict' ){
feature <- self$data_imputed[,setdiff(colnames(self$data_imputed),colnames(context))]
}
if(self$column_counter == 0 & self$flag=='train'){
feature <- self$data_imputed[,setdiff(colnames(self$data_imputed),colnames(context))]
self$flag=='predict'
self$imputed_predict <- FALSE
}
return(feature)
}
)
)
test <- PipeOpmissForest$new()
graph =  test %>>% learner_po
glrn = GraphLearner$new(graph)
glrn$train(d)
resample(d, glrn, rsmp("cv"))
PipeOpmissForest <-  R6::R6Class("missForest_imputation",lock_objects=FALSE,
inherit = PipeOpImpute,  # inherit from PipeOp
public = list(
initialize = function(id = "imput_missForest", cores=NULL,ntree_set=c(100,200,500,1000),mtry_set=NULL,parallel=TRUE
,col_0_1=FALSE,mtry=NULL,ntree=100,optimize=FALSE,maxiter=20,maxnodes=NULL
) {
super$initialize(id,whole_task_dependent=TRUE,param_vals = list(cores =cores,ntree_set =ntree_set,mtry_set=mtry_set,parallel=parallel,
col_0_1=col_0_1,mtry=mtry,ntree=ntree,optimize=optimize,
maxiter=maxiter,maxnodes=maxnodes),
param_set= ParamSet$new(list(
'ntree_set'=ParamUty$new('ntree_set', default = c(100,200,500,1000), tags = 'missForest'),
'cores'=ParamUty$new('cores',default = NULL,tags='missForest'),
'mtry_set'=ParamUty$new('mtry_set',default = NULL,tags='missForest'),
'parallel'=ParamLgl$new('parallel',default = TRUE,tags = 'missForest'),
'col_0_1'=ParamLgl$new('col_0_1',default = F,tags='missForest'),
'mtry'=ParamUty$new('mtry',default = NULL,tags='missForest'),
'ntree'=ParamInt$new('ntree',lower = 10,upper = Inf,default = 100,tags='missForest'),
'optimize'=ParamLgl$new('optimize',default = FALSE,tags='missForest'),
'maxiter'=ParamInt$new('maxiter',lower = 5,upper = Inf,default = 20,tags='missForest'),
'maxnodes'=ParamUty$new('maxnodes',default = NULL,tags='missForest')
)),
)
self$imp_function <- function(data_to_impute){
data_to_impute <- as.data.frame(data_to_impute)
# prepering arguments for function
col_type <- 1:ncol(data_to_impute)
for (i in col_type){
col_type[i] <- class(data_to_impute[,i])
}
percent_of_missing <- 1:ncol(data_to_impute)
for (i in percent_of_missing){
percent_of_missing[i] <- (sum(is.na(data_to_impute[,i]))/length(data_to_impute[,1]))*100
}
col_miss <- colnames(data_to_impute)[percent_of_missing>0]
col_no_miss <- colnames(data_to_impute)[percent_of_missing==0]
data_imputed <- autotune_missForest(data_to_impute,percent_of_missing = percent_of_missing,cores = self$param_set$values$cores,
ntree_set = self$param_set$values$ntree_set,mtry_set = self$param_set$values$mtry_set,
parallel = self$param_set$values$parallel,
col_0_1 = self$param_set$values$col_0_1,optimize = self$param_set$values$optimize,
ntree = self$param_set$values$ntree,mtry = self$param_set$values$mtry,
maxiter=self$param_set$values$maxiter,maxnodes=self$param_set$values$maxnodes,verbose = F)
return(data_imputed)
}
self$imputed <- FALSE
self$column_counter <- NULL
self$data_imputed <- NULL
},
train_imputer=function(feature, type, context){
self$imputed_predict <- TRUE
self$flag <- 'train'
if(!self$imputed){
print('train')
self$column_counter <- ncol(context)+1
self$imputed <- TRUE
data_to_impute <- cbind(feature,context)
self$data_imputed <- self$imp_function(data_to_impute)
colnames(self$data_imputed) <- self$state$context_cols
}
if(self$imputed){
self$column_counter <- self$column_counter -1
}
if  (self$column_counter==0){
self$imputed <- FALSE
}
return(NULL)
},
impute=function(feature, type, model, context){
if (self$imputed){
feature <- self$data_imputed[,setdiff(colnames(self$data_imputed),colnames(context))]
}
if(nrow(self$data_imputed)!=nrow(context)){
self$imputed_predict <- FALSE
self$flag <- 'predict'
}
if(!self$imputed_predict){
print('predict')
data_to_impute <- cbind(feature,context)
self$data_imputed <- self$imp_function(data_to_impute)
colnames(self$data_imputed) <- self$state$context_cols
self$imputed_predict <- TRUE
}
if (self$imputed_predict & self$flag=='predict' ){
feature <- self$data_imputed[,setdiff(colnames(self$data_imputed),colnames(context))]
}
if(self$column_counter == 0 & self$flag=='train'){
feature <- self$data_imputed[,setdiff(colnames(self$data_imputed),colnames(context))]
self$flag=='predict'
self$imputed_predict <- FALSE
}
return(feature)
}
)
)
mlr_pipeops$add("missForest_imputation", PipeOpmissForest)
test <- PipeOpmissForest$new()
graph =  test %>>% learner_po
glrn = GraphLearner$new(graph)
resample(d, glrn, rsmp("cv"))
#' @param ntree ntree from missForest function
#' @param mtry mtry form missforest function
#' @param verbose If FALSE funtion didn't print on console.
#' @param maxiter maxiter form missForest function.
#' @param maxnodes maxnodes from missForest function.
#' @import missForest
#' @import doParallel
#' @param col_0_1 decide if add bonus column informing where imputation been done. 0 - value was in dataset, 1 - value was imputed. Default False.
#'
#' @return Return data.frame with imputed values.
autotune_missForest <-function(df,percent_of_missing,cores=NULL,ntree_set =c(100,200,500,1000),mtry_set=NULL,parallel=TRUE,col_0_1=FALSE,
optimize=TRUE,ntree=100,mtry=NULL,verbose=FALSE,maxiter=20,maxnodes=NULL){
# Checking if parallel backed is runing and starting it if not
if (parallel){
veribles = ncol(df)
if (ceiling(detectCores()/2)>=veribles){cores <- (veribles-2)}
registerDoParallel(cores = cores)
}
# Prepering mtry_set if not given
if (is.null(mtry_set)){
mtry_set <- 1:4
mtry_set[1] <- floor(sqrt(ncol(df)))
if (mtry_set[1]>1){
mtry_set[2] <- ceiling(mtry_set[1]/2)
vector <- (mtry_set[1]:ncol(df))
mtry_set[3] <- floor(length(vector)/3)
mtry_set[4] <- floor(2*length(vector)/3)
}
else{
vector <- (mtry_set[1]:ncol(df))
mtry_set[2] <- flor(length(vector)/4)
mtry_set[3] <- floor(2*length(vector)/4)
mtry_set[4] <- floor(3*length(vector)/4)
}
}
# If parallel=TRUE
parallelize <- 'no'
if (parallel){
parallelize <-  'variables'}
if (optimize){
# Grid search using mean OBBerror
best_params <-  c(-11,-11)
best_OBB <- 10
for (i in ntree_set)
{
for (j in mtry_set){
skip_to_next <- FALSE
tryCatch({
iteration <-  mean(missForest(df,maxiter = maxiter,ntree = i,mtry = j,parallelize=parallelize,maxnodes = maxnodes,verbose = verbose)$OOBerror)
if (iteration<best_OBB){
best_OBB <- iteration
best_params[1] <- i
best_params[2] <- j
}
}, error = function(e) { skip_to_next <<- TRUE})
if(skip_to_next) { next }
}
}
#fianl imputation
final <- missForest(df,maxiter = maxiter,maxnodes = maxnodes,ntree = best_params[1],mtry = best_params[2],parallelize=parallelize,verbose = verbose)$ximp
}
if (!optimize){
if (is.null(mtry)){
final <- missForest(df,maxiter = maxiter,ntree = ntree,maxnodes = maxnodes,mtry = floor(sqrt(ncol(df))),parallelize = parallelize,verbose = verbose)$ximp}
else{ final <- missForest(df,maxiter = maxiter,ntree = ntree,maxnodes = maxnodes,mtry = mtry,parallelize = parallelize,verbose = verbose)$ximp}
}
#adding 0_1_cols
if (col_0_1){
columns_with_missing <-  (as.data.frame(is.na(df))*1)[,percent_of_missing>0]
colnames(columns_with_missing) <- paste(colnames(columns_with_missing),'where',sep='_')
final <- cbind(final,columns_with_missing)
}
# turn off paralllel
if (parallel){
registerDoSEQ()
}
return(final)
}
PipeOpmissForest <-  R6::R6Class("missForest_imputation",lock_objects=FALSE,
inherit = PipeOpImpute,  # inherit from PipeOp
public = list(
initialize = function(id = "imput_missForest", cores=NULL,ntree_set=c(100,200,500,1000),mtry_set=NULL,parallel=TRUE
,col_0_1=FALSE,mtry=NULL,ntree=100,optimize=FALSE,maxiter=20,maxnodes=NULL
) {
super$initialize(id,whole_task_dependent=TRUE,param_vals = list(cores =cores,ntree_set =ntree_set,mtry_set=mtry_set,parallel=parallel,
col_0_1=col_0_1,mtry=mtry,ntree=ntree,optimize=optimize,
maxiter=maxiter,maxnodes=maxnodes),
param_set= ParamSet$new(list(
'ntree_set'=ParamUty$new('ntree_set', default = c(100,200,500,1000), tags = 'missForest'),
'cores'=ParamUty$new('cores',default = NULL,tags='missForest'),
'mtry_set'=ParamUty$new('mtry_set',default = NULL,tags='missForest'),
'parallel'=ParamLgl$new('parallel',default = TRUE,tags = 'missForest'),
'col_0_1'=ParamLgl$new('col_0_1',default = F,tags='missForest'),
'mtry'=ParamUty$new('mtry',default = NULL,tags='missForest'),
'ntree'=ParamInt$new('ntree',lower = 10,upper = Inf,default = 100,tags='missForest'),
'optimize'=ParamLgl$new('optimize',default = FALSE,tags='missForest'),
'maxiter'=ParamInt$new('maxiter',lower = 5,upper = Inf,default = 20,tags='missForest'),
'maxnodes'=ParamUty$new('maxnodes',default = NULL,tags='missForest')
)),
)
self$imp_function <- function(data_to_impute){
data_to_impute <- as.data.frame(data_to_impute)
# prepering arguments for function
col_type <- 1:ncol(data_to_impute)
for (i in col_type){
col_type[i] <- class(data_to_impute[,i])
}
percent_of_missing <- 1:ncol(data_to_impute)
for (i in percent_of_missing){
percent_of_missing[i] <- (sum(is.na(data_to_impute[,i]))/length(data_to_impute[,1]))*100
}
col_miss <- colnames(data_to_impute)[percent_of_missing>0]
col_no_miss <- colnames(data_to_impute)[percent_of_missing==0]
data_imputed <- autotune_missForest(data_to_impute,percent_of_missing = percent_of_missing,cores = self$param_set$values$cores,
ntree_set = self$param_set$values$ntree_set,mtry_set = self$param_set$values$mtry_set,
parallel = self$param_set$values$parallel,
col_0_1 = self$param_set$values$col_0_1,optimize = self$param_set$values$optimize,
ntree = self$param_set$values$ntree,mtry = self$param_set$values$mtry,
maxiter=self$param_set$values$maxiter,maxnodes=self$param_set$values$maxnodes,verbose = F)
return(data_imputed)
}
self$imputed <- FALSE
self$column_counter <- NULL
self$data_imputed <- NULL
},
train_imputer=function(feature, type, context){
self$imputed_predict <- TRUE
self$flag <- 'train'
if(!self$imputed){
print('train')
self$column_counter <- ncol(context)+1
self$imputed <- TRUE
data_to_impute <- cbind(feature,context)
self$data_imputed <- self$imp_function(data_to_impute)
colnames(self$data_imputed) <- self$state$context_cols
}
if(self$imputed){
self$column_counter <- self$column_counter -1
}
if  (self$column_counter==0){
self$imputed <- FALSE
}
return(NULL)
},
impute=function(feature, type, model, context){
if (self$imputed){
feature <- self$data_imputed[,setdiff(colnames(self$data_imputed),colnames(context))]
}
if(nrow(self$data_imputed)!=nrow(context)){
self$imputed_predict <- FALSE
self$flag <- 'predict'
}
if(!self$imputed_predict){
print('predict')
data_to_impute <- cbind(feature,context)
self$data_imputed <- self$imp_function(data_to_impute)
colnames(self$data_imputed) <- self$state$context_cols
self$imputed_predict <- TRUE
}
if (self$imputed_predict & self$flag=='predict' ){
feature <- self$data_imputed[,setdiff(colnames(self$data_imputed),colnames(context))]
}
if(self$column_counter == 0 & self$flag=='train'){
feature <- self$data_imputed[,setdiff(colnames(self$data_imputed),colnames(context))]
self$flag=='predict'
self$imputed_predict <- FALSE
}
return(feature)
}
)
)
PipeOpMice <-  R6::R6Class("mice_imputation",lock_objects=FALSE,
inherit = PipeOpImpute,
public = list(
initialize = function(id = "imput_mice", m=5,maxit=5,set_cor=0.5,
set_method='pmm',low_corr=0,up_corr=1,
methods_random=c('pmm'),iter=5,random.seed=123,optimize = F,correlation=T,col_0_1=F
) {
super$initialize(id, whole_task_dependent=TRUE,param_vals = list( m=m,maxit=maxit,set_cor=set_cor,
set_method=set_method,low_corr=low_corr,up_corr=up_corr,
methods_random=methods_random,iter=iter,random.seed=random.seed,optimize = optimize,correlation=correlation,col_0_1=col_0_1),
param_set= ParamSet$new(list(
'set_cor'=ParamDbl$new('set_cor', lower = 0, upper = 1, special_vals = list(), default = 0.4, tags = 'mice'),
'iter'=ParamInt$new('iter',lower = 1,upper = Inf,default = 5,tags='mice'),
'm'=ParamInt$new('m',lower = 1,upper = Inf,default = 2,tags='mice'),
'maxit'=ParamInt$new('maxit',lower = 5,upper = 100,default = 5,tags='mice'),
'set_method'=ParamFct$new('set_method',levels = c('pmm','midastouch','sample','cart'),default = 'pmm',tags='mice'),
'low_corr'=ParamDbl$new('low_corr',lower = 0,upper = 1,default = 0,tags='mice'),
'up_corr'=ParamDbl$new('up_corr',lower = 0,upper = 1,default = 1,tags='mice'),
'methods_random'=ParamFct$new('methods_random',levels=c('pmm','midastouch','sample','cart'),default = c('pmm'),tag='mice'),
'random.seed'=ParamInt$new('random.seed',-Inf,Inf,default = 123,tags='mice'),
'optimize'=ParamLgl$new('optimize',default = F,tags='mice'),
'col_0_1'=ParamLgl$new('col_0_1',default = F,tags='mice'),
'correlation'=ParamLgl$new('correlation',default = T,tags='mice')
))
)
self$imp_function <- function(data_to_impute){
data_to_impute <- as.data.frame(data_to_impute)
# prepering arguments for function
col_type <- 1:ncol(data_to_impute)
for (i in col_type){
col_type[i] <- class(data_to_impute[,i])
}
percent_of_missing <- 1:ncol(data_to_impute)
for (i in percent_of_missing){
percent_of_missing[i] <- (sum(is.na(data_to_impute[,i]))/length(data_to_impute[,1]))*100
}
col_miss <- colnames(data_to_impute)[percent_of_missing>0]
col_no_miss <- colnames(data_to_impute)[percent_of_missing==0]
data_imputed <- autotune_mice(data_to_impute,col_miss = col_miss,col_no_miss = col_no_miss,col_type = col_type,
percent_of_missing = percent_of_missing,m=self$param_set$values$m,iter=self$param_set$values$iter,
maxit = self$param_set$values$maxit,
low_corr = self$param_set$values$low_corr,up_corr = self$param_set$values$up_corr,
set_cor = self$param_set$values$set_cor,set_method = self$param_set$values$set_method,
methods_random = self$param_set$values$methods_random,random.seed = self$param_set$values$random.seed,
optimize = self$param_set$values$optimize,
correlation = self$param_set$values$correlation,col_0_1 = self$param_set$values$col_0_1
)
return(data_imputed)
}
self$imputed <- FALSE
self$column_counter <- NULL
self$data_imputed <- NULL
},
train_imputer=function(feature, type, context){
self$imputed_predict <- TRUE
self$flag <- 'train'
if(!self$imputed){
self$column_counter <- ncol(context)+1
self$imputed <- TRUE
data_to_impute <- cbind(feature,context)
self$data_imputed <- self$imp_function(data_to_impute)
colnames(self$data_imputed) <- self$state$context_cols
}
if(self$imputed){
self$column_counter <- self$column_counter -1
}
if  (self$column_counter==0){
self$imputed <- FALSE
}
return(NULL)
},
impute=function(feature, type, model, context){
if (self$imputed){
feature <- self$data_imputed[,setdiff(colnames(self$data_imputed),colnames(context))]
}
if(nrow(self$data_imputed)!=nrow(context)){
self$imputed_predict <- FALSE
self$flag <- 'predict'
}
if(!self$imputed_predict){
data_to_impute <- cbind(feature,context)
self$data_imputed <- self$imp_function(data_to_impute)
colnames(self$data_imputed) <- self$state$context_cols
self$imputed_predict <- TRUE
}
if (self$imputed_predict & self$flag=='predict' ){
feature <- self$data_imputed[,setdiff(colnames(self$data_imputed),colnames(context))]
}
if(self$column_counter == 0 & self$flag=='train'){
feature <- self$data_imputed[,setdiff(colnames(self$data_imputed),colnames(context))]
self$flag=='predict'
self$imputed_predict <- FALSE
}
return(feature)
}
)
)
test <- PipeOpmissForest$new()
graph =  test %>>% learner_po
glrn = GraphLearner$new(graph)
resample(d, glrn, rsmp("cv"))
PipeOpVIM_kNN <-  R6::R6Class("VIM_kNN_imputation",lock_objects=FALSE,
inherit = PipeOpImpute,
public = list(
initialize = function(id = "imput_VIM_kNN", k=5,numFun=median,catFun=maxCat,col_0_1=FALSE
) {
super$initialize(id, whole_task_dependent=TRUE,param_vals = list(k=k,numFun=numFun,catFun=catFun,col_0_1=col_0_1 ),
param_set= ParamSet$new(list(
'k'=ParamInt$new('k',lower = 1,upper = Inf,default = 5,tags='VIM_kNN'),
'numFun'=ParamUty$new('numFun',default = median,tags = 'VIM_kNN'),
'catFun'=ParamUty$new('catFun',default = maxCat,tags = 'VIM_kNN'),
'col_0_1'=ParamLgl$new('col_0_1',default = FALSE,tags = 'VIM_kNN')
))
)
self$imp_function <- function(data_to_impute){
data_to_impute <- as.data.frame(data_to_impute)
# prepering arguments for function
col_type <- 1:ncol(data_to_impute)
for (i in col_type){
col_type[i] <- class(data_to_impute[,i])
}
percent_of_missing <- 1:ncol(data_to_impute)
for (i in percent_of_missing){
percent_of_missing[i] <- (sum(is.na(data_to_impute[,i]))/length(data_to_impute[,1]))*100
}
col_miss <- colnames(data_to_impute)[percent_of_missing>0]
col_no_miss <- colnames(data_to_impute)[percent_of_missing==0]
data_imputed <- autotune_VIM_kNN(data_to_impute,percent_of_missing ,k =self$param_set$values$k,numFun = self$param_set$values$numFun,
catFun = self$param_set$values$catFun,col_0_1 = self$param_set$values$col_0_1)
return(data_imputed)
}
self$imputed <- FALSE
self$column_counter <- NULL
self$data_imputed <- NULL
},
train_imputer=function(feature, type, context){
self$imputed_predict <- TRUE
self$flag <- 'train'
if(!self$imputed){
self$column_counter <- ncol(context)+1
self$imputed <- TRUE
data_to_impute <- cbind(feature,context)
self$data_imputed <- self$imp_function(data_to_impute)
colnames(self$data_imputed) <- self$state$context_cols
}
if(self$imputed){
self$column_counter <- self$column_counter -1
}
if  (self$column_counter==0){
self$imputed <- FALSE
}
return(NULL)
},
impute=function(feature, type, model, context){
if (self$imputed){
feature <- self$data_imputed[,setdiff(colnames(self$data_imputed),colnames(context))]
}
if(nrow(self$data_imputed)!=nrow(context)){
self$imputed_predict <- FALSE
self$flag <- 'predict'
}
if(!self$imputed_predict){
data_to_impute <- cbind(feature,context)
self$data_imputed <- self$imp_function(data_to_impute)
colnames(self$data_imputed) <- self$state$context_cols
self$imputed_predict <- TRUE
}
if (self$imputed_predict & self$flag=='predict' ){
feature <- self$data_imputed[,setdiff(colnames(self$data_imputed),colnames(context))]
}
if(self$column_counter == 0 & self$flag=='train'){
feature <- self$data_imputed[,setdiff(colnames(self$data_imputed),colnames(context))]
self$flag=='predict'
self$imputed_predict <- FALSE
}
return(feature)
}
)
)
test <- PipeOpVIM_kNN$new()
graph =  test %>>% learner_po
glrn = GraphLearner$new(graph)
resample(d, glrn, rsmp("cv"))
?irmi
test <- irmi(dataset)
View(test)
test <- irmi(dataset,robust = T)
test <- irmi(dataset,robust = T,step=T)
test <- irmi(dataset,step=T)
test <- irmi(dataset,mi=3)
tryCatch({
final <- irmi(df,eps=eps,maxit = maxit,step = step,robust = robust,init.method = init.method,force = force,imp_var = F)
}error = function(e){
print('IRMI dont work on selcted params runing on defoult')
final <- irmi(df,imp_var = F)
})
autotune_VIM_Irmi <- function(df,percent_of_missing,mi=1,eps=5,maxit=100,step=FALSE,robust=FALSE,init.method='kNN',force=FALSE,col_0_1=FALSE){
tryCatch({
final <- irmi(df,eps=eps,maxit = maxit,step = step,robust = robust,init.method = init.method,force = force,imp_var = F)
},error = function(e){
print('IRMI dont work on selcted params runing on defoult')
final <- irmi(df,imp_var = F)
})
if(col_0_1){
columns_with_missing <-  (as.data.frame(is.na(df))*1)[,percent_of_missing>0]
colnames(columns_with_missing) <- paste(colnames(columns_with_missing),'where',sep='_')
final <- cbind(final,columns_with_missing)
}
return(final)
}
library(devtools)
document()
