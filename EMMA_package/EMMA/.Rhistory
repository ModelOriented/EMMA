}
#conecting df back
final <- cbind(as.data.frame(final),df[,ifelse(col_type=='numeric' | col_type=='integer',F,T)])
final <- final[,column_order]
if(col_0_1){
columns_with_missing <-  (as.data.frame(is.na(df))*1)[,percent_of_missing>0]
colnames(columns_with_missing) <- paste(colnames(columns_with_missing),'where',sep='_')
final <- cbind(final,columns_with_missing)
}
return(final)
}
autotune_softImpute(df,percent_of_missing,col_type,col_0_1,cat_Fun=maxCat,lambda=0,rank.max=2,type='als',thresh=1e-5,maxit=100){
column_order <- colnames(df)
if(sum(is.na(df))==0){return(df)}
if(is.null(rank.max)){
rank.max <- min(dim(df))-1
}
#Prepering matrix
matrix <- as.matrix(df[,ifelse(col_type=='numeric' | col_type=='integer',TRUE,FALSE)])
if(is.null(lambda)){
lambda <- floor(lambda0(matrix,thresh = thresh,maxit = maxit))
}
#Numeric Imputation
result <- softImpute(matrix,lambda = lambda,rank.max = rank.max,thresh = thresh,maxit = maxit)
final <- complete(matrix,result)
#Categorical Imputation
iter_vec <- colnames(df)[col_type=='factor' & percent_of_missing>0]
for (i in iter_vec){
col_to_imp <- df[,i]
col_to_imp[is.na(col_to_imp)] <- cat_Fun(col_to_imp)
df[,i] <- col_to_imp
}
#conecting df back
final <- cbind(as.data.frame(final),df[,ifelse(col_type=='numeric' | col_type=='integer',F,T)])
final <- final[,column_order]
if(col_0_1){
columns_with_missing <-  (as.data.frame(is.na(df))*1)[,percent_of_missing>0]
colnames(columns_with_missing) <- paste(colnames(columns_with_missing),'where',sep='_')
final <- cbind(final,columns_with_missing)
}
return(final)
}
autotune_softImpute(df,percent_of_missing,col_type,col_0_1=F,cat_Fun=maxCat,lambda=0,rank.max=2,type='als',thresh=1e-5,maxit=100){
column_order <- colnames(df)
if(sum(is.na(df))==0){return(df)}
if(is.null(rank.max)){
rank.max <- min(dim(df))-1
}
#Prepering matrix
matrix <- as.matrix(df[,ifelse(col_type=='numeric' | col_type=='integer',TRUE,FALSE)])
if(is.null(lambda)){
lambda <- floor(lambda0(matrix,thresh = thresh,maxit = maxit))
}
#Numeric Imputation
result <- softImpute(matrix,lambda = lambda,rank.max = rank.max,thresh = thresh,maxit = maxit)
final <- complete(matrix,result)
#Categorical Imputation
iter_vec <- colnames(df)[col_type=='factor' & percent_of_missing>0]
for (i in iter_vec){
col_to_imp <- df[,i]
col_to_imp[is.na(col_to_imp)] <- cat_Fun(col_to_imp)
df[,i] <- col_to_imp
}
#conecting df back
final <- cbind(as.data.frame(final),df[,ifelse(col_type=='numeric' | col_type=='integer',F,T)])
final <- final[,column_order]
if(col_0_1){
columns_with_missing <-  (as.data.frame(is.na(df))*1)[,percent_of_missing>0]
colnames(columns_with_missing) <- paste(colnames(columns_with_missing),'where',sep='_')
final <- cbind(final,columns_with_missing)
}
return(final)
}
autotune_softImpute <- function(df,percent_of_missing,col_type,col_0_1=F,cat_Fun=maxCat,lambda=0,rank.max=2,type='als',thresh=1e-5,maxit=100){
column_order <- colnames(df)
if(sum(is.na(df))==0){return(df)}
if(is.null(rank.max)){
rank.max <- min(dim(df))-1
}
#Prepering matrix
matrix <- as.matrix(df[,ifelse(col_type=='numeric' | col_type=='integer',TRUE,FALSE)])
if(is.null(lambda)){
lambda <- floor(lambda0(matrix,thresh = thresh,maxit = maxit))
}
#Numeric Imputation
result <- softImpute(matrix,lambda = lambda,rank.max = rank.max,thresh = thresh,maxit = maxit)
final <- complete(matrix,result)
#Categorical Imputation
iter_vec <- colnames(df)[col_type=='factor' & percent_of_missing>0]
for (i in iter_vec){
col_to_imp <- df[,i]
col_to_imp[is.na(col_to_imp)] <- cat_Fun(col_to_imp)
df[,i] <- col_to_imp
}
#conecting df back
final <- cbind(as.data.frame(final),df[,ifelse(col_type=='numeric' | col_type=='integer',F,T)])
final <- final[,column_order]
if(col_0_1){
columns_with_missing <-  (as.data.frame(is.na(df))*1)[,percent_of_missing>0]
colnames(columns_with_missing) <- paste(colnames(columns_with_missing),'where',sep='_')
final <- cbind(final,columns_with_missing)
}
return(final)
}
test <- data
col_type <- 1:ncol(test)
for (i in col_type){
col_type[i] <- class(test[,i])
}
percent_of_missing <- 1:ncol(test)
for (i in percent_of_missing){
percent_of_missing[i] <- (sum(is.na(test[,i]))/length(test[,1]))*100
}
wynik_test <- autotune_softImpute(test,col_type = col_type,percent_of_missing)
wynik_test <- autotune_softImpute(test,col_type = col_type,percent_of_missing = percent_of_missing)
sum(is.na(wynik_test))
sum(is.na(data))
test <- df
col_type <- 1:ncol(test)
for (i in col_type){
col_type[i] <- class(test[,i])
}
percent_of_missing <- 1:ncol(test)
for (i in percent_of_missing){
percent_of_missing[i] <- (sum(is.na(test[,i]))/length(test[,1]))*100
}
wynik_test <- autotune_softImpute(test,col_type = col_type,percent_of_missing = percent_of_missing)
for (i in col_type){
col_type[i] <- class(test[,i])
}
test <- df
col_type <- 1:ncol(test)
for (i in col_type){
col_type[i] <- class(test[,i])
}
percent_of_missing <- 1:ncol(test)
for (i in percent_of_missing){
percent_of_missing[i] <- (sum(is.na(test[,i]))/length(test[,1]))*100
}
wynik_test <- autotune_softImpute(test,col_type = col_type,percent_of_missing = percent_of_missing)
source('~/.active-rstudio-document', echo=TRUE)
debugSource('~/Pulpit/Job_repo/EMMA/EMMA_package/EMMA/R/autotune_softImpute.R', echo=TRUE)
debugSource('~/Pulpit/Job_repo/EMMA/EMMA_package/EMMA/R/autotune_softImpute.R', echo=TRUE)
View(final)
autotune_softImpute <- function(df,percent_of_missing,col_type,col_0_1=F,cat_Fun=maxCat,lambda=0,rank.max=2,type='als',thresh=1e-5,maxit=100){
column_order <- colnames(df)
if(sum(is.na(df))==0){return(df)}
if(is.null(rank.max)){
rank.max <- min(dim(df))-1
}
#Prepering matrix
matrix <- as.matrix(df[,ifelse(col_type=='numeric' | col_type=='integer',TRUE,FALSE)])
if(is.null(lambda)){
lambda <- floor(lambda0(matrix,thresh = thresh,maxit = maxit))
}
#Numeric Imputation
result <- softImpute(matrix,lambda = lambda,rank.max = rank.max,thresh = thresh,maxit = maxit)
final <- complete(matrix,result)
#Categorical Imputation
iter_vec <- colnames(df)[col_type=='factor' & percent_of_missing>0]
for (i in iter_vec){
col_to_imp <- df[,i]
col_to_imp[is.na(col_to_imp)] <- cat_Fun(col_to_imp)
df[,i] <- col_to_imp
}
#conecting df back
final <- cbind(as.data.frame(final),df[,ifelse(col_type=='numeric' | col_type=='integer',F,T),drop=F])
final <- final[,column_order]
if(col_0_1){
columns_with_missing <-  (as.data.frame(is.na(df))*1)[,percent_of_missing>0]
colnames(columns_with_missing) <- paste(colnames(columns_with_missing),'where',sep='_')
final <- cbind(final,columns_with_missing)
}
return(final)
}
test <- df
col_type <- 1:ncol(test)
for (i in col_type){
col_type[i] <- class(test[,i])
}
percent_of_missing <- 1:ncol(test)
for (i in percent_of_missing){
percent_of_missing[i] <- (sum(is.na(test[,i]))/length(test[,1]))*100
}
wynik_test <- autotune_softImpute(test,col_type = col_type,percent_of_missing = percent_of_missing)
View(wynik_test)
df_oml <- getOMLDataSet(41162)
df <- preprocess(df_oml,0.9)[[1]]
col_type <- 1:ncol(df)
for ( i in col_type){
col_type[i] <- class(df[,i])
}
percent_of_missing  <- 1:ncol(df)
for ( i in percent_of_missing){
percent_of_missing[i] <- (sum(is.na(df[,i]))/length(df[,1]))*100
}
library(dplyr)
library(janitor)
library(tidyselect)
require(EMMA)
library(mlr3learners)
library(OpenML)
preprocess <- function(df_oml, miss_in_var_threshold = 0.9) {
### Params
# - df_oml: object from getOMLDataSet()
# - miss_in_var_threshold: values [0, 1]; defines threshold of missings in columns to remove
### Output
# - df: ready, cleaned dataframe
# - data_types_troubles: flag for column types trouble
# - miss_in_target: flag for missing values in target variable
df <- df_oml$data
df_desc <- df_oml$desc
id <- df_desc$id
### Preprocessing step ###
check_type <- function(x){
is.numeric(x) | is.factor(x)
}
#Flags
data_types_troubles <- FALSE
miss_in_target <- FALSE
#Columns to ignore according to tags
to_ignore <- df_desc$ignore.attribute
if (all(!is.na(to_ignore))) {
df <- select(df,-all_of(to_ignore))
}
#Removing row ID column according to tags
row_id <- df_desc$row.id.attribute
row_id <- row_id[!row_id %in% to_ignore]
if (all(!is.na(row_id))) {
df <- select(df,-all_of(row_id))
}
#Data types
data_types_check <- sapply(df, check_type)
if (any(!data_types_check)) {
wrong_columns <- colnames(df)[!data_types_check]
#Trying possible conversions
for (col in wrong_columns) {
if (is.logical(df[, col]) | is.character(df[, col])) {
df[, col] <- as.factor(df[, col])
} else{
warning(paste("Data type trouble ID: ", id))
data_types_troubles <- TRUE
}
}
}
#Removing possible duplicate rows
df <- df[!duplicated(df),]
#Removing constant columns
df <- remove_constant(df)
#Removing empty columns
df <- remove_empty(df, "cols")
#All to lowercase
df <- mutate_if(df, is.factor, function(x)
factor(tolower(x)))
#Missing values in target variable
target <- df_oml$target.features
if (any(is.na(df[, target]))) {
miss_in_target <- TRUE
warning(paste("Missing values in target variable ID: ", id))
}
#Removing columns with % of missing higher than "miss_in_var_threshold"
df <- df[, which(colMeans(!is.na(df)) > miss_in_var_threshold)]
#Categorical columns with high fraction of unique values
#?
return(list("df" = df,
"data_types_troubles" = data_types_troubles,
"miss_in_target" = miss_in_target))
}
check_type <- function(x){
is.numeric(x) | is.factor(x)
}
data_types_troubles <- c()
miss_in_target <- c()
df_oml <- getOMLDataSet(41162)
df <- preprocess(df_oml,0.9)[[1]]
col_type <- 1:ncol(df)
for ( i in col_type){
col_type[i] <- class(df[,i])
}
percent_of_missing  <- 1:ncol(df)
for ( i in percent_of_missing){
percent_of_missing[i] <- (sum(is.na(df[,i]))/length(df[,1]))*100
}
#
test <- df
col_type <- 1:ncol(test)
for (i in col_type){
col_type[i] <- class(test[,i])
}
percent_of_missing <- 1:ncol(test)
for (i in percent_of_missing){
percent_of_missing[i] <- (sum(is.na(test[,i]))/length(test[,1]))*100
}
wynik_test <- autotune_softImpute(test,col_type = col_type,percent_of_missing = percent_of_missing)
sum(is.na(wynik_test))
sum(is.na(df))
?softImpute
library(devtools)
document()
document()
mlr_pipeops$add("VIM_regrImp_imputation", PipeOpVIM_regrImp)
PipeOpVIM_regrImp <-  R6::R6Class("VIM_regrImp_imputation",lock_objects=FALSE,
inherit = PipeOpImpute,  # inherit from PipeOp
public = list(
initialize = function(id = "imput_VIM_regrImp",col_0_1= FALSE,robust=FALSE,mod_cat=FALSE,use_imputed=FALSE
) {
super$initialize(id, whole_task_dependent=TRUE, param_vals = list( col_0_1=col_0_1,robust=robust,mod_cat=mod_cat,
use_imputed=use_imputed),
param_set= ParamSet$new(list(
'col_0_1'=ParamLgl$new('col_0_1',default = F,tags='VIM_regrImp'),
'robust'=ParamLgl$new('robust',default = F,tags = 'VIM_regrImp'),
'mod_cat'=ParamLgl$new('mod_cat',default = F,tags='VIM_regrImp'),
'use_imputed'=ParamLgl$new('use_imputed',default = F,tags = 'VIM_regrImp')
))
)
self$imputed <- FALSE
self$column_counter <- NULL
self$data_imputed <- NULL
},
train_imputer=function(feature, type, context){
imp_function <- function(data_to_impute){
data_to_impute <- as.data.frame(data_to_impute)
# prepering arguments for function
col_type <- 1:ncol(data_to_impute)
for (i in col_type){
col_type[i] <- class(data_to_impute[,i])
}
percent_of_missing <- 1:ncol(data_to_impute)
for (i in percent_of_missing){
percent_of_missing[i] <- (sum(is.na(data_to_impute[,i]))/length(data_to_impute[,1]))*100
}
col_miss <- colnames(data_to_impute)[percent_of_missing>0]
col_no_miss <- colnames(data_to_impute)[percent_of_missing==0]
data_imputed <- autotune_VIM_regrImp(data_to_impute,percent_of_missing = percent_of_missing,col_type = col_type,
col_0_1 = self$param_set$values$col_0_1,robust = self$param_set$values$robust,
mod_cat = self$param_set$values$mod_cat , use_imputed = self$param_set$values$use_imputed)
return(data_imputed)
}
self$imputed_predict <- TRUE
self$flag <- 'train'
if(!self$imputed){
self$column_counter <- ncol(context)+1
self$imputed <- TRUE
data_to_impute <- cbind(feature,context)
self$data_imputed <- imp_function(data_to_impute)
colnames(self$data_imputed) <- self$state$context_cols
}
if(self$imputed){
self$column_counter <- self$column_counter -1
}
if  (self$column_counter==0){
self$imputed <- FALSE
}
self$train_s <- TRUE
return(NULL)
},
impute=function(feature, type, model, context){
imp_function <- function(data_to_impute){
data_to_impute <- as.data.frame(data_to_impute)
# prepering arguments for function
col_type <- 1:ncol(data_to_impute)
for (i in col_type){
col_type[i] <- class(data_to_impute[,i])
}
percent_of_missing <- 1:ncol(data_to_impute)
for (i in percent_of_missing){
percent_of_missing[i] <- (sum(is.na(data_to_impute[,i]))/length(data_to_impute[,1]))*100
}
col_miss <- colnames(data_to_impute)[percent_of_missing>0]
col_no_miss <- colnames(data_to_impute)[percent_of_missing==0]
data_imputed <- autotune_VIM_regrImp(data_to_impute,percent_of_missing = percent_of_missing,col_type = col_type,
col_0_1 = self$param_set$values$col_0_1,robust = self$param_set$values$robust,
mod_cat = self$param_set$values$mod_cat , use_imputed = self$param_set$values$use_imputed)
return(data_imputed)
}
if (self$imputed){
feature <- self$data_imputed[,setdiff(colnames(self$data_imputed),colnames(context))]
}
if((nrow(self$data_imputed)!=nrow(context) | !self$train_s) & (self$flag=='train')){
self$imputed_predict <- FALSE
self$flag <- 'predict'
}
if(!self$imputed_predict){
data_to_impute <- cbind(feature,context)
self$data_imputed <- imp_function(data_to_impute)
colnames(self$data_imputed) <- self$state$context_cols
self$imputed_predict <- TRUE
}
if (self$imputed_predict & self$flag=='predict' ){
feature <- self$data_imputed[,setdiff(colnames(self$data_imputed),colnames(context))]
}
if(self$column_counter == 0 & self$flag=='train'){
feature <- self$data_imputed[,setdiff(colnames(self$data_imputed),colnames(context))]
self$flag <- 'predict'
self$imputed_predict <- FALSE
}
self$train_s <- FALSE
return(feature)
}
)
)
mlr_pipeops$add("VIM_regrImp_imputation", PipeOpVIM_regrImp)
document()
library(EMMMA)
library(EMMA)
?autotune_softImpute
PipeOpSoftImpute <-  R6::R6Class("softImpute_imputation",lock_objects=FALSE,
inherit = PipeOpImpute,  # inherit from PipeOp
public = list(
initialize = function(id = "imput_softImpute",col_0_1=F,cat_Fun=maxCat,lambda=0,rank.max=2,type='als',thresh=1e-5,maxit=100
) {
super$initialize(id, whole_task_dependent=TRUE, param_vals = list( col_0_1=col_0_1,cat_Fun=cat_Fun,lambda=lambda,
rank.max=rank.max,type=type,thresh,thresh,maxit=maxit),
param_set= ParamSet$new(list(
'col_0_1'=ParamLgl$new('col_0_1',default = F,tags='softImpute'),
'cat_Fun'=ParamUty$new('cat_Fun',default = maxCat,tags = 'softImpute'),
'lambda'=ParamUty$new('lambda',default = 0,tags = 'softImpute'),
'rank.max'=ParamUty$new('rank.max',default = 2,tags = 'softImpute'),
'type'=ParamFct$new('type',levels = c('als','svd'),default = 'als',tags='softImpute'),
'thresh'=ParamDbl$new('thresh',upper = Inf,lower = 0,default = 1e-5,tags = 'softImpute'),
'maxit'=ParamDbl$new('maxit',upper = Inf,lower = 1,default = 100,tags='softImpute')
))
)
self$imputed <- FALSE
self$column_counter <- NULL
self$data_imputed <- NULL
},
train_imputer=function(feature, type, context){
imp_function <- function(data_to_impute){
data_to_impute <- as.data.frame(data_to_impute)
# prepering arguments for function
col_type <- 1:ncol(data_to_impute)
for (i in col_type){
col_type[i] <- class(data_to_impute[,i])
}
percent_of_missing <- 1:ncol(data_to_impute)
for (i in percent_of_missing){
percent_of_missing[i] <- (sum(is.na(data_to_impute[,i]))/length(data_to_impute[,1]))*100
}
col_miss <- colnames(data_to_impute)[percent_of_missing>0]
col_no_miss <- colnames(data_to_impute)[percent_of_missing==0]
data_imputed <- autotune_softImpute(data_to_impute,percent_of_missing = percent_of_missing,col_type = col_type,
col_0_1 = self$param_set$values$col_0_1,cat_Fun = self$param_set$values$cat_Fun,
lambda = self$param_set$values$lambda,rank.max = self$param_set$values$rank.max,
type = self$param_set$values$type,thresh = self$param_set$values$thresh,
maxit = self$param_set$values$maxit)
return(data_imputed)
}
self$imputed_predict <- TRUE
self$flag <- 'train'
if(!self$imputed){
self$column_counter <- ncol(context)+1
self$imputed <- TRUE
data_to_impute <- cbind(feature,context)
self$data_imputed <- imp_function(data_to_impute)
colnames(self$data_imputed) <- self$state$context_cols
}
if(self$imputed){
self$column_counter <- self$column_counter -1
}
if  (self$column_counter==0){
self$imputed <- FALSE
}
self$train_s <- TRUE
return(NULL)
},
impute=function(feature, type, model, context){
imp_function <- function(data_to_impute){
data_to_impute <- as.data.frame(data_to_impute)
# prepering arguments for function
col_type <- 1:ncol(data_to_impute)
for (i in col_type){
col_type[i] <- class(data_to_impute[,i])
}
percent_of_missing <- 1:ncol(data_to_impute)
for (i in percent_of_missing){
percent_of_missing[i] <- (sum(is.na(data_to_impute[,i]))/length(data_to_impute[,1]))*100
}
data_imputed <- autotune_softImpute(data_to_impute,percent_of_missing = percent_of_missing,col_type = col_type,
col_0_1 = self$param_set$values$col_0_1,cat_Fun = self$param_set$values$cat_Fun,
lambda = self$param_set$values$lambda,rank.max = self$param_set$values$rank.max,
type = self$param_set$values$type,thresh = self$param_set$values$thresh,
maxit = self$param_set$values$maxit)
return(data_imputed)
}
if (self$imputed){
feature <- self$data_imputed[,setdiff(colnames(self$data_imputed),colnames(context))]
}
if((nrow(self$data_imputed)!=nrow(context) |  !self$train_s) & self$flag=='train'){
self$imputed_predict <- FALSE
self$flag <- 'predict'
}
if(!self$imputed_predict){
data_to_impute <- cbind(feature,context)
self$data_imputed <- imp_function(data_to_impute)
colnames(self$data_imputed) <- self$state$context_cols
self$imputed_predict <- TRUE
}
if (self$imputed_predict & self$flag=='predict' ){
feature <- self$data_imputed[,setdiff(colnames(self$data_imputed),colnames(context))]
}
if(self$column_counter == 0 & self$flag=='train'){
feature <- self$data_imputed[,setdiff(colnames(self$data_imputed),colnames(context))]
self$flag <- 'predict'
self$imputed_predict <- FALSE
}
self$train_s <- FALSE
return(feature)
}
)
)
mlr_pipeops$add("softImpute_imputation",PipeOpSoftImpute)
