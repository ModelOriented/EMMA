if (all(!is.na(row_id))) {
df <- select(df,-all_of(row_id))
}
#Data types
data_types_check <- sapply(df, check_type)
if (any(!data_types_check)) {
wrong_columns <- colnames(df)[!data_types_check]
#Trying possible conversions
for (col in wrong_columns) {
if (is.logical(df[, col]) | is.character(df[, col])) {
df[, col] <- as.factor(df[, col])
} else{
warning(paste("Data type trouble ID: ", id))
data_types_troubles <- TRUE
}
}
}
#Removing possible duplicate rows
df <- df[!duplicated(df),]
#Removing constant columns
df <- remove_constant(df)
#Removing empty columns
df <- remove_empty(df, "cols")
#All to lowercase
df <- mutate_if(df, is.factor, function(x)
factor(tolower(x)))
#Missing values in target variable
target <- df_oml$target.features
if (any(is.na(df[, target]))) {
miss_in_target <- TRUE
warning(paste("Missing values in target variable ID: ", id))
}
#Removing columns with % of missing higher than "miss_in_var_threshold"
df <- df[, which(colMeans(!is.na(df)) > miss_in_var_threshold)]
#Categorical columns with high fraction of unique values
#?
return(list("df" = df,
"data_types_troubles" = data_types_troubles,
"miss_in_target" = miss_in_target))
}
#######
out_file <- paste0(OutLogLocation,outfilename)
datasets_Ids <- c(4,15,25,38,802,930,957,961,40945,41162)
write(paste0('LOG',Sys.Date()),file = out_file)
check_type <- function(x){
is.numeric(x) | is.factor(x)
}
data_types_troubles <- c()
miss_in_target <- c()
list_of_pipe <- c(PipeOpMice,PipeOpMissMDA_MFA,PipeOpMissMDA_PCA_MCA_FMAD,PipeOpmissForest,PipeOpVIM_HD,PipeOpVIM_IRMI,
PipeOpVIM_kNN)
for(id in datasets_Ids){
df_oml <- getOMLDataSet(25)
df <- preprocess(df_oml,0.9)[[1]]
col_type <- 1:ncol(df)
for ( i in col_type){
col_type[i] <- class(df[,i])
}
percent_of_missing  <- 1:ncol(df)
for ( i in percent_of_missing){
percent_of_missing[i] <- (sum(is.na(df[,i]))/length(df[,1]))*100
}
write('----------------------IMPUTACJE-----------------------',append = T,file=out_file)
single_set_Pipeline(df,id,col_type,percent_of_missing,out_file_location = out_file,single_set = FALSE)
write('----------------------PIPLINE-----------------------',append = T,file=out_file)
for (i in list_of_pipe){
tryCatch({
learner_po = po("learner", learner = lrn("classif.rpart"))
test_imp <- i$new()
test = test_imp %>>%  learner_po
glrn =GraphLearner$new(test)
test_task = TaskClassif$new('test',backend = df,target = df_oml$target.features)
cat(test_imp$id,file = out_file,append = T)
resample(test_task,glrn,rsmp('cv',folds=2L))
write('ok',file=out_file,append = T)
},error=function(e){
write(as.character(e),file = out_file,append = T)
})
}
}
library(EMMA)
?mlr_pipeops
mlr3pipelines
document()
?PipeOpSoftImpute
#' @title PipeOpImputeOOR
#'
#' @usage NULL
#' @name mlr_pipeops_imputeoor
#' @format [`R6Class`] object inheriting from [`PipeOpImpute`]/[`PipeOp`].
#'
#' @description
#' Impute factorial features by adding a new level `".MISSING"`.
#'
#' Impute numerical features by constant values shifted below the minimum or above the maximum by
#' using \eqn{min(x) - offset - multiplier * diff(range(x))} or
#' \eqn{max(x) + offset + multiplier * diff(range(x))}.
#'
#' This type of imputation is especially sensible in the context of tree-based methods, see also
#' Ding & Simonoff (2010).
#'
#' @section Construction:
#' ```
#' PipeOpImputeOOR$new(id = "imputeoor", param_vals = list())
#' ```
#'
#' * `id` :: `character(1)`\cr
#'   Identifier of resulting object, default `"imputeoor"`.
#' * `param_vals` :: named `list`\cr
#'   List of hyperparameter settings, overwriting the hyperparameter settings that would otherwise be set during construction. Default `list()`.
#'
#' @section Input and Output Channels:
#' Input and output channels are inherited from [`PipeOpImpute`].
#'
#' The output is the input [`Task`][mlr3::Task] with all affected features having missing values imputed as described above.
#'
#' @section State:
#' The `$state` is a named `list` with the `$state` elements inherited from [`PipeOpImpute`].
#'
#' The `$state$model` contains either `".MISSING"` used for `character` and `factor` (also
#' `ordered`) features or `numeric(1)` indicating the constant value used for imputation of
#' `integer` and `numeric` features.
#'
#' @section Parameters:
#' The parameters are the parameters inherited from [`PipeOpImpute`], as well as:
#' * `min` :: `logical(1)` \cr
#'   Should `integer` and `numeric` features be shifted below the minimum? Default is TRUE. If FALSE
#'   they are shifted above the maximum. See also the description above.
#' * `offset` :: `numeric(1)` \cr
#'   Numerical non-negative offset as used in the description above for `integer` and `numeric`
#'   features. Default is 1.
#' * `multiplier` :: `numeric(1)` \cr
#'   Numerical non-negative multiplier as used in the description above for `integer` and `numeric`
#'   features. Default is 1.
#'
#' @section Internals:
#' Adds an explicit new `level()` to `factor` and `ordered` features, but not to `character` features.
#' For `integer` and `numeric` features uses the `min`, `max`, `diff` and `range` functions.
#' `integer` and `numeric` features that are entirely `NA` are imputed as `0`.
#'
#' @section Methods:
#' Only methods inherited from [`PipeOpImpute`]/[`PipeOp`].
#'
#' @examples
#' library("mlr3")
#' set.seed(2409)
#' data = tsk("pima")$data()
#' data$y = factor(c(NA, sample(letters, size = 766, replace = TRUE), NA))
#' data$z = ordered(c(NA, sample(1:10, size = 767, replace = TRUE)))
#' task = TaskClassif$new("task", backend = data, target = "diabetes")
#' task$missings()
#' po = po("imputeoor")
#' new_task = po$train(list(task = task))[[1]]
#' new_task$missings()
#' new_task$data()
#' @family PipeOps
#' @family Imputation PipeOps
#' @include PipeOpImpute.R
#' @export
PipeOpImputeOOR = R6Class("PipeOpImputeOOR",
inherit = PipeOpImpute,
public = list(
initialize = function(id = "imputeoor", param_vals = list()) {
ps = ParamSet$new(params = list(
ParamLgl$new("min", default = TRUE, tags = c("train", "predict")),
ParamDbl$new("offset", lower = 0, default = 1, tags = c("train", "predict")),
ParamDbl$new("multiplier", lower = 0, default = 1, tags = c("train", "predict")))
)
ps$values = list(min = TRUE, offset = 1, multiplier = 1)
super$initialize(id, param_set = ps, param_vals = param_vals)
}
),
private = list(
# this is one of the few imputers that handles 'character' features!
.select_cols = function(task) task$feature_types[get("type") %in% c("character", "factor", "integer", "numeric", "ordered"), get("id")],
.train_imputer = function(feature, type, context) {
if (type %in% c("factor", "ordered", "character")) {
return(".MISSING")  # early exit
}
# for integer or numeric do
oor = if (self$param_set$values$min) {
min(feature, na.rm = TRUE) - self$param_set$values$offset - self$param_set$values$multiplier * diff(range(feature, na.rm = TRUE))
} else {
max(feature, na.rm = TRUE) + self$param_set$values$offset + self$param_set$values$multiplier * diff(range(feature, na.rm = TRUE))
}
# if the feature only consists of NA/NaN values, oor will be NaN if offset and multiplier are 0;
# oor will be Inf if offset and multiplier are larger than 0
if (is.nan(oor) || is.infinite(oor)) {
oor = 0
}
if (type == "integer") {
oor = as.integer(round(oor))
}
oor
},
.impute = function(feature, type, model, context) {
if (type %in% c("factor", "ordered")) {
levels(feature) = c(levels(feature), ".MISSING")
}
feature[is.na(feature)] = model
feature
}
)
)
mlr_pipeops$add("imputeoor", PipeOpImputeOOR)
#' task = TaskClassif$new("task", backend = data, target = "diabetes")
#' task$missings()
#' po = po("imputeoor")
#' new_task = po$train(list(task = task))[[1]]
#' new_task$missings()
#' new_task$data()
#' @family PipeOps
#' @family Imputation PipeOps
#' @include PipeOpImpute.R
#' @export
PipeOpImputeOOR = R6Class("PipeOpImputeOOR",
inherit = PipeOpImpute,
public = list(
initialize = function(id = "imputeoor", param_vals = list()) {
ps = ParamSet$new(params = list(
ParamLgl$new("min", default = TRUE, tags = c("train", "predict")),
ParamDbl$new("offset", lower = 0, default = 1, tags = c("train", "predict")),
ParamDbl$new("multiplier", lower = 0, default = 1, tags = c("train", "predict")))
)
ps$values = list(min = TRUE, offset = 1, multiplier = 1)
super$initialize(id, param_set = ps, param_vals = param_vals)
}
),
private = list(
# this is one of the few imputers that handles 'character' features!
.select_cols = function(task) task$feature_types[get("type") %in% c("character", "factor", "integer", "numeric", "ordered"), get("id")],
.train_imputer = function(feature, type, context) {
if (type %in% c("factor", "ordered", "character")) {
return(".MISSING")  # early exit
}
# for integer or numeric do
oor = if (self$param_set$values$min) {
min(feature, na.rm = TRUE) - self$param_set$values$offset - self$param_set$values$multiplier * diff(range(feature, na.rm = TRUE))
} else {
max(feature, na.rm = TRUE) + self$param_set$values$offset + self$param_set$values$multiplier * diff(range(feature, na.rm = TRUE))
}
# if the feature only consists of NA/NaN values, oor will be NaN if offset and multiplier are 0;
# oor will be Inf if offset and multiplier are larger than 0
if (is.nan(oor) || is.infinite(oor)) {
oor = 0
}
if (type == "integer") {
oor = as.integer(round(oor))
}
oor
},
.impute = function(feature, type, model, context) {
if (type %in% c("factor", "ordered")) {
levels(feature) = c(levels(feature), ".MISSING")
}
feature[is.na(feature)] = model
feature
}
)
)
#' task = TaskClassif$new("task", backend = data, target = "diabetes")
#' task$missings()
#' po = po("imputeoor")
#' new_task = po$train(list(task = task))[[1]]
#' new_task$missings()
#' new_task$data()
#' @family PipeOps
#' @family Imputation PipeOps
#' @include PipeOpImpute.R
#' @export
PipeOpImputeOOR = R6::R6Class("PipeOpImputeOOR",
inherit = PipeOpImpute,
public = list(
initialize = function(id = "imputeoor", param_vals = list()) {
ps = ParamSet$new(params = list(
ParamLgl$new("min", default = TRUE, tags = c("train", "predict")),
ParamDbl$new("offset", lower = 0, default = 1, tags = c("train", "predict")),
ParamDbl$new("multiplier", lower = 0, default = 1, tags = c("train", "predict")))
)
ps$values = list(min = TRUE, offset = 1, multiplier = 1)
super$initialize(id, param_set = ps, param_vals = param_vals)
}
),
private = list(
# this is one of the few imputers that handles 'character' features!
.select_cols = function(task) task$feature_types[get("type") %in% c("character", "factor", "integer", "numeric", "ordered"), get("id")],
.train_imputer = function(feature, type, context) {
if (type %in% c("factor", "ordered", "character")) {
return(".MISSING")  # early exit
}
# for integer or numeric do
oor = if (self$param_set$values$min) {
min(feature, na.rm = TRUE) - self$param_set$values$offset - self$param_set$values$multiplier * diff(range(feature, na.rm = TRUE))
} else {
max(feature, na.rm = TRUE) + self$param_set$values$offset + self$param_set$values$multiplier * diff(range(feature, na.rm = TRUE))
}
# if the feature only consists of NA/NaN values, oor will be NaN if offset and multiplier are 0;
# oor will be Inf if offset and multiplier are larger than 0
if (is.nan(oor) || is.infinite(oor)) {
oor = 0
}
if (type == "integer") {
oor = as.integer(round(oor))
}
oor
},
.impute = function(feature, type, model, context) {
if (type %in% c("factor", "ordered")) {
levels(feature) = c(levels(feature), ".MISSING")
}
feature[is.na(feature)] = model
feature
}
)
)
mlr_pipeops$add("imputeoor", PipeOpImputeOOR)
?PipeOpImputeOOR
?PipeOpImputeNewlvl
d
d$backend
w <- PipeOpImputeNewlvl
w <- PipeOpImputeNewlvl$new()
test <- PipeOpImputeNewlvl$new()
graph =  test %>>% learner_po
glrn = GraphLearner$new(graph)
resample(d, glrn, rsmp("cv"))
source('~/.active-rstudio-document', echo=TRUE)
w$outnum
w$train(d)
w$train(list(d))
w
c<- w$predict(list(d))
c
c$data()
c$data
c$output$data()
sum(is.null(c$output$data()))
sum(is.null(d$data()))
View(df)
d$backend
d$data()
sum(is.null(c$output$backend))
d$backend
sum(is.null(d$backend))
s.null(d$backend)
(is.null(d$backend)
d$data()
d$data()
is.null(d$data())
is.na(d$data())
sum(is.na(c$output$data()))
sum(is.na(d$data()))
#' task = TaskClassif$new("task", backend = data, target = "diabetes")
#' task$missings()
#' po = po("imputeoor")
#' new_task = po$train(list(task = task))[[1]]
#' new_task$missings()
#' new_task$data()
#' @family PipeOps
#' @family Imputation PipeOps
#' @include PipeOpImpute.R
#' @export
PipeOpImputeOOR = R6::R6Class("PipeOpImputeOOR",
inherit = PipeOpImpute,
public = list(
initialize = function(id = "imputeoor", param_vals = list()) {
ps = ParamSet$new(params = list(
ParamLgl$new("min", default = TRUE, tags = c("train", "predict")),
ParamDbl$new("offset", lower = 0, default = 1, tags = c("train", "predict")),
ParamDbl$new("multiplier", lower = 0, default = 1, tags = c("train", "predict")))
)
ps$values = list(min = TRUE, offset = 1, multiplier = 1)
super$initialize(id, param_set = ps, param_vals = param_vals)
}
),
private = list(
# this is one of the few imputers that handles 'character' features!
.select_cols = function(task) task$feature_types[get("type") %in% c("character", "factor", "integer", "numeric", "ordered"), get("id")],
.train_imputer = function(feature, type, context) {
if (type %in% c("factor", "ordered", "character")) {
return(".MISSING")  # early exit
}
# for integer or numeric do
oor = if (self$param_set$values$min) {
min(feature, na.rm = TRUE) - self$param_set$values$offset - self$param_set$values$multiplier * diff(range(feature, na.rm = TRUE))
} else {
max(feature, na.rm = TRUE) + self$param_set$values$offset + self$param_set$values$multiplier * diff(range(feature, na.rm = TRUE))
}
# if the feature only consists of NA/NaN values, oor will be NaN if offset and multiplier are 0;
# oor will be Inf if offset and multiplier are larger than 0
if (is.nan(oor) || is.infinite(oor)) {
oor = 0
}
if (type == "integer") {
oor = as.integer(round(oor))
}
oor
},
.impute = function(feature, type, model, context) {
if (type %in% c("factor", "ordered")) {
levels(feature) = c(levels(feature), ".MISSING")
}
feature[is.na(feature)] = model
feature
}
)
)
mlr_pipeops$add("imputeoor", PipeOpImputeOOR)
w <- PipeOpImputeOOR$new()
test <- PipeOpImputeNewlvl$new()
graph =  test %>>% learner_po
glrn = GraphLearner$new(graph)
resample(d, glrn, rsmp("cv"))
w$train(list(d))
c<- w$predict(list(d))
sum(is.na(d$data()))
is.na(c$output$data())
sum(is.na(c$output$data()))
sum(is.na(d$data()))
w
f <- PipeOpImputeNewlvl$new()
f
document()
document()
#' @title PipeOpImputeOOR FROM MLR3piplinies git hub repo
#'
#' @usage NULL
#' @name mlr_pipeops_imputeoor
#' @format [`R6Class`] object inheriting from [`PipeOpImpute`]/[`PipeOp`].
#'
#' @description
#' Impute factorial features by adding a new level `".MISSING"`.
#'
#' Impute numerical features by constant values shifted below the minimum or above the maximum by
#' using \eqn{min(x) - offset - multiplier * diff(range(x))} or
#' \eqn{max(x) + offset + multiplier * diff(range(x))}.
#'
#' This type of imputation is especially sensible in the context of tree-based methods, see also
#' Ding & Simonoff (2010).
#'
#'
#' @section Parameters:
#'
#' * `min` :: `logical(1)` \cr
#'   Should `integer` and `numeric` features be shifted below the minimum? Default is TRUE. If FALSE
#'   they are shifted above the maximum. See also the description above.
#' * `offset` :: `numeric(1)` \cr
#'   Numerical non-negative offset as used in the description above for `integer` and `numeric`
#'   features. Default is 1.
#' * `multiplier` :: `numeric(1)` \cr
#'   Numerical non-negative multiplier as used in the description above for `integer` and `numeric`
#'   features. Default is 1.
#'
#' @section Internals:
#' Adds an explicit new `level()` to `factor` and `ordered` features, but not to `character` features.
#' For `integer` and `numeric` features uses the `min`, `max`, `diff` and `range` functions.
#' `integer` and `numeric` features that are entirely `NA` are imputed as `0`.
#'
#' @section Methods:
#' Only methods inherited from [`PipeOpImpute`]/[`PipeOp`].
#'
#' @family PipeOps
#' @family Imputation PipeOps
#' @export
PipeOpImputeOOR = R6::R6Class("PipeOpImputeOOR",
inherit = PipeOpImpute,
public = list(
initialize = function(id = "imputeoor", param_vals = list()) {
ps = ParamSet$new(params = list(
ParamLgl$new("min", default = TRUE, tags = c("train", "predict")),
ParamDbl$new("offset", lower = 0, default = 1, tags = c("train", "predict")),
ParamDbl$new("multiplier", lower = 0, default = 1, tags = c("train", "predict")))
)
ps$values = list(min = TRUE, offset = 1, multiplier = 1)
super$initialize(id, param_set = ps, param_vals = param_vals)
}
),
private = list(
# this is one of the few imputers that handles 'character' features!
.select_cols = function(task) task$feature_types[get("type") %in% c("character", "factor", "integer", "numeric", "ordered"), get("id")],
.train_imputer = function(feature, type, context) {
if (type %in% c("factor", "ordered", "character")) {
return(".MISSING")  # early exit
}
# for integer or numeric do
oor = if (self$param_set$values$min) {
min(feature, na.rm = TRUE) - self$param_set$values$offset - self$param_set$values$multiplier * diff(range(feature, na.rm = TRUE))
} else {
max(feature, na.rm = TRUE) + self$param_set$values$offset + self$param_set$values$multiplier * diff(range(feature, na.rm = TRUE))
}
# if the feature only consists of NA/NaN values, oor will be NaN if offset and multiplier are 0;
# oor will be Inf if offset and multiplier are larger than 0
if (is.nan(oor) || is.infinite(oor)) {
oor = 0
}
if (type == "integer") {
oor = as.integer(round(oor))
}
oor
},
.impute = function(feature, type, model, context) {
if (type %in% c("factor", "ordered")) {
levels(feature) = c(levels(feature), ".MISSING")
}
feature[is.na(feature)] = model
feature
}
)
)
mlr_pipeops$add("imputeoor", PipeOpImputeOOR)
document()
document()
