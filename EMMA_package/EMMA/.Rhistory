predicted_value <- col_no_miss[1]
if (sum(percent_of_missing>0)>=3){
columns_missing  <-  as.data.frame(cbind(percent_of_missing,colnames(df)))
columns_missing <- columns_missing[order(as.numeric(as.character(columns_missing$percent_of_missing)),decreasing = TRUE),]
predicting_values <- columns_missing$V2[1:3]
}
else{ predicting_values <- col_miss}
}
return(list(as.formula(paste(as.character(predicted_value),paste(as.character(predicting_values),collapse = '+'),sep='~')),no_numeric))
}
single_set_Pipeline(df,id,col_type,percent_of_missing,out_file_location = 'LOG_PIPLINIE',single_set = FALSE)
#' @param iter number of iteration for randomSearch.
#' @param random.seed random seed.
#' @param optimize_no_numeric if user wont to optimize.
#' @param correlation If True correlation is using if Fales fraction of features. Default True.
#' @param return_one One or many imputed sets will be returned. Default True.
#' @param col_0_1 Decaid if add bonus column informing where imputation been done. 0 - value was in dataset, 1 - value was imputed. Default False. (Works only for returning one dataset).
#'
#'
#'
#' @return Return imputed datasets or mids object containing multi imputation datasets.
autotune_mice <- function(df,m=5,maxit=5,col_miss,col_no_miss,col_type,percent_of_missing,low_corr=0,up_corr=1,methods_random=c('pmm'),iter,random.seed=123,optimize = T,correlation=T,return_one=T,col_0_1 = F ){
formula_cre <- formula_creating(df,col_miss,col_no_miss,col_type,percent_of_missing)
formula <- formula_cre[1]
no_numeric <- as.logical(formula_cre[2])
# If user chose to optimise no numeric dataset
if (optimize){
params <- random_param_mice_search(df=df,low_corr = low_corr,up_corr = up_corr,methods_random = methods_random,formula = formula,no_numeric = no_numeric,random.seed = random.seed,iter=iter,correlation = correlation)
#If user chose to use correlation
if (correlation){
imp_final <- mice(df,m=m,maxit = maxit,method = as.character(params[2]),pred=quickpred(df, mincor=as.numeric(params[1]),method = 'spearman'),seed = random.seed)
}
if (!correlation){
imp_final <- mice(df,m=m,maxit = maxit,method = as.character(params[2]),pred=quickpred(df, minpuc = as.numeric(params[1]),method = 'spearman'),seed = random.seed)
}
}
if (!optimize){
if (correlation){
imp_final <- mice(df,m=m,maxit = maxit,method = 'pmm',pred=quickpred(df, mincor=0.5,method = 'spearman'),seed = random.seed)
}
if (!correlation){
imp_final <- mice(df,m=m,maxit = maxit,method = 'pmm',pred=quickpred(df, minpuc = 0.5,method = 'spearman'),seed = random.seed)
}
}
# If user chose to return one dataset
if (return_one){
imputed_dataset <- complete(imp_final)
# If user chose to return 0,1 columns
if (col_0_1 ){
where_imputed <- as.data.frame(imp_final$where)[,imp_final$nmis>0]
colnames(where_imputed) <- paste(colnames(where_imputed),'where',sep = '_')
imputed_dataset <- cbind(imputed_dataset,where_imputed*1)
}
return(imputed_dataset)
}
if(!return_one){
return(imp_final)
}
}
View(autotune_mice)
write(paste0('LOG',Sys.Date()),file = 'LOG_PIPLINIE')
for(id in datasets$ID[1:20]){
df_oml <- getOMLDataSet(id)
df_desc <- df_oml$desc
df <- df_oml$data
### Preprocessing step ###
#Columns to ignore according to tags
to_ignore <- df_desc$ignore.attribute
if(!is.na(to_ignore)){
df <- select(df, -all_of(to_ignore))
}
#Removing row ID column according to tags
row_id <- df_desc$row.id.attribute
if(!is.na(row_id)){
df <- select(df, -all_of(row_id))
}
#Data types
data_types_check <- sapply(df, check_type)
if(any(!data_types_check)){
wrong_columns <- colnames(df)[!data_types_check]
#Trying possible conversions
for(col in wrong_columns){
if(is.logical(df[,col]) | is.character(df[,col])){
df[,col] <- as.factor(df[,col])
}else{
warning(paste("Data type trouble ID: ", as.character(id)))
data_types_troubles <- c(data_types_troubles, id)
}
}
}
#Removing possible duplicate rows
df <- df[!duplicated(df), ]
#Removing constant columns
df <- remove_constant(df)
#Removing empty columns
df <- remove_empty(df, "cols")
#All to lowercase
df <- mutate_if(df, is.factor, function(x) factor(tolower(x)))
#Missing values in target variable
target <- df_oml$target.features
if(any(is.na(df[, target]))){
miss_in_target <- c(miss_in_target, id)
warning(paste("Missing values in target variable ID: ", as.character(id)))
}
##
### OUTPUT FILE LOCATION
##
col_type <- 1:ncol(df)
for ( i in col_type){
col_type[i] <- class(df[,i])
}
percent_of_missing  <- 1:ncol(df)
for ( i in percent_of_missing){
percent_of_missing[i] <- (sum(is.na(df[,i]))/length(df[,1]))*100
}
single_set_Pipeline(df,id,col_type,percent_of_missing,out_file_location = 'LOG_PIPLINIE',single_set = FALSE)
}
View(df)
col_type_simpler <-  ifelse(col_type=='factor','n','s')
groups <- c(99999999)
type <- c('remove')
counter <- 1
for (i in 1:(length(col_type_simpler)-1)){
flag <- col_type_simpler[i+1]
if (flag ==col_type_simpler[i]){
counter <- counter +1
if (i +1 == length(col_type_simpler)){groups <- c(groups,counter)
type <- c(type,col_type_simpler[i+1])}
}
if (flag !=col_type_simpler[i]){
groups <- c(groups,counter)
type <- c(type,col_type_simpler[i])
counter <- 1
if (i +1 == length(col_type_simpler)){groups <- c(groups,counter)
type <- c(type,col_type_simpler[i+1])}
}}
groups <- groups[-1]
type <- type[-1]
# Imputation
final <-  imputeMFA(df,group = groups,type = type,ncp = ncp,method = 'Regularized')$completeObs
# Imputation
final <-  imputeMFA(df,group = groups,type = type,ncp = 2,method = 'Regularized')$completeObs
missMDA_MFA <- function(df,col_type,percent_of_missing,random.seed=123,ncp =2 ,col_0_1=F){
#Creating gropus
col_type_simpler <-  ifelse(col_type=='factor','n','s')
groups <- c(99999999)
type <- c('remove')
counter <- 1
for (i in 1:(length(col_type_simpler)-1)){
flag <- col_type_simpler[i+1]
if (flag ==col_type_simpler[i]){
counter <- counter +1
if (i +1 == length(col_type_simpler)){groups <- c(groups,counter)
type <- c(type,col_type_simpler[i+1])}
}
if (flag !=col_type_simpler[i]){
groups <- c(groups,counter)
type <- c(type,col_type_simpler[i])
counter <- 1
if (i +1 == length(col_type_simpler)){groups <- c(groups,counter)
type <- c(type,col_type_simpler[i+1])}
}}
groups <- groups[-1]
type <- type[-1]
if (length(groups )==1 ){
groups <- c(flor(groups/2),groups-flor(groups/2))
type <- rep(type[1],2)
}
# Imputation
final <-  imputeMFA(df,group = groups,type = type,ncp = ncp,method = 'Regularized')$completeObs
# adding 0_1 columns
if (col_0_1){
columns_with_missing <-  (as.data.frame(is.na(df))*1)[,percent_of_missing>0]
colnames(columns_with_missing) <- paste(colnames(columns_with_missing),'where',sep='_')
final <- cbind(final,columns_with_missing)
}
return(final)
}
groups <- c(99999999)
type <- c('remove')
counter <- 1
for (i in 1:(length(col_type_simpler)-1)){
flag <- col_type_simpler[i+1]
if (flag ==col_type_simpler[i]){
counter <- counter +1
if (i +1 == length(col_type_simpler)){groups <- c(groups,counter)
type <- c(type,col_type_simpler[i+1])}
}
if (flag !=col_type_simpler[i]){
groups <- c(groups,counter)
type <- c(type,col_type_simpler[i])
counter <- 1
if (i +1 == length(col_type_simpler)){groups <- c(groups,counter)
type <- c(type,col_type_simpler[i+1])}
}}
groups <- groups[-1]
type <- type[-1]
if (length(groups )==1 ){
groups <- c(flor(groups/2),groups-flor(groups/2))
type <- rep(type[1],2)
}
col_type_simpler <-  ifelse(col_type=='factor','n','s')
groups <- c(99999999)
type <- c('remove')
counter <- 1
for (i in 1:(length(col_type_simpler)-1)){
flag <- col_type_simpler[i+1]
if (flag ==col_type_simpler[i]){
counter <- counter +1
if (i +1 == length(col_type_simpler)){groups <- c(groups,counter)
type <- c(type,col_type_simpler[i+1])}
}
if (flag !=col_type_simpler[i]){
groups <- c(groups,counter)
type <- c(type,col_type_simpler[i])
counter <- 1
if (i +1 == length(col_type_simpler)){groups <- c(groups,counter)
type <- c(type,col_type_simpler[i+1])}
}}
groups <- groups[-1]
type <- type[-1]
if (length(groups )==1 ){
groups <- c(floor(groups/2),groups-floor(groups/2))
type <- rep(type[1],2)
}
# Imputation
missMDA_MFA <- function(df,col_type,percent_of_missing,random.seed=123,ncp =2 ,col_0_1=F){
#Creating gropus
col_type_simpler <-  ifelse(col_type=='factor','n','s')
groups <- c(99999999)
type <- c('remove')
counter <- 1
for (i in 1:(length(col_type_simpler)-1)){
flag <- col_type_simpler[i+1]
if (flag ==col_type_simpler[i]){
counter <- counter +1
if (i +1 == length(col_type_simpler)){groups <- c(groups,counter)
type <- c(type,col_type_simpler[i+1])}
}
if (flag !=col_type_simpler[i]){
groups <- c(groups,counter)
type <- c(type,col_type_simpler[i])
counter <- 1
if (i +1 == length(col_type_simpler)){groups <- c(groups,counter)
type <- c(type,col_type_simpler[i+1])}
}}
groups <- groups[-1]
type <- type[-1]
if (length(groups )==1 ){
groups <- c(floor(groups/2),groups-floor(groups/2))
type <- rep(type[1],2)
}
# Imputation
final <-  imputeMFA(df,group = groups,type = type,ncp = ncp,method = 'Regularized')$completeObs
# adding 0_1 columns
if (col_0_1){
columns_with_missing <-  (as.data.frame(is.na(df))*1)[,percent_of_missing>0]
colnames(columns_with_missing) <- paste(colnames(columns_with_missing),'where',sep='_')
final <- cbind(final,columns_with_missing)
}
return(final)
}
# Imputation
final <-  imputeMFA(df,group = groups,type = type,ncp = 2,method = 'Regularized')$completeObs
# Imputation
final <-  imputeMFA(df,group = groups,type = type,ncp = 2,method = 'Regularized')$completeObs
missMDA_MFA <- function(df,col_type,percent_of_missing,random.seed=123,ncp =2 ,col_0_1=F){
#Creating gropus
col_type_simpler <-  ifelse(col_type=='factor','n','s')
groups <- c(99999999)
type <- c('remove')
counter <- 1
for (i in 1:(length(col_type_simpler)-1)){
flag <- col_type_simpler[i+1]
if (flag ==col_type_simpler[i]){
counter <- counter +1
if (i +1 == length(col_type_simpler)){groups <- c(groups,counter)
type <- c(type,col_type_simpler[i+1])}
}
if (flag !=col_type_simpler[i]){
groups <- c(groups,counter)
type <- c(type,col_type_simpler[i])
counter <- 1
if (i +1 == length(col_type_simpler)){groups <- c(groups,counter)
type <- c(type,col_type_simpler[i+1])}
}}
groups <- groups[-1]
type <- type[-1]
if (length(groups )==1 ){
groups <- c(floor(groups/2),groups-floor(groups/2))
type <- rep(type[1],2)
}
# Imputation
final <-  imputeMFA(df,group = groups,type = type,ncp = ncp,method = 'Regularized')$completeObs
# adding 0_1 columns
if (col_0_1){
columns_with_missing <-  (as.data.frame(is.na(df))*1)[,percent_of_missing>0]
colnames(columns_with_missing) <- paste(colnames(columns_with_missing),'where',sep='_')
final <- cbind(final,columns_with_missing)
}
return(final)
}
out_file <- 'LOG_PIPELINIE'
write(paste0('LOG',Sys.Date()),file = out_file)
for(id in datasets$ID[1:20]){
df_oml <- getOMLDataSet(id)
df_desc <- df_oml$desc
df <- df_oml$data
### Preprocessing step ###
#Columns to ignore according to tags
to_ignore <- df_desc$ignore.attribute
if(!is.na(to_ignore)){
df <- select(df, -all_of(to_ignore))
}
#Removing row ID column according to tags
row_id <- df_desc$row.id.attribute
if(!is.na(row_id)){
df <- select(df, -all_of(row_id))
}
#Data types
data_types_check <- sapply(df, check_type)
if(any(!data_types_check)){
wrong_columns <- colnames(df)[!data_types_check]
#Trying possible conversions
for(col in wrong_columns){
if(is.logical(df[,col]) | is.character(df[,col])){
df[,col] <- as.factor(df[,col])
}else{
warning(paste("Data type trouble ID: ", as.character(id)))
data_types_troubles <- c(data_types_troubles, id)
}
}
}
#Removing possible duplicate rows
df <- df[!duplicated(df), ]
#Removing constant columns
df <- remove_constant(df)
#Removing empty columns
df <- remove_empty(df, "cols")
#All to lowercase
df <- mutate_if(df, is.factor, function(x) factor(tolower(x)))
#Missing values in target variable
target <- df_oml$target.features
if(any(is.na(df[, target]))){
miss_in_target <- c(miss_in_target, id)
warning(paste("Missing values in target variable ID: ", as.character(id)))
}
##
### OUTPUT FILE LOCATION
##
col_type <- 1:ncol(df)
for ( i in col_type){
col_type[i] <- class(df[,i])
}
percent_of_missing  <- 1:ncol(df)
for ( i in percent_of_missing){
percent_of_missing[i] <- (sum(is.na(df[,i]))/length(df[,1]))*100
}
single_set_Pipeline(df,id,col_type,percent_of_missing,out_file_location = out_file,single_set = FALSE)
}
missMDA_MFA <- function(df,col_type,percent_of_missing,random.seed=123,ncp =2 ,col_0_1=F){
#Creating gropus
col_type_simpler <-  ifelse(col_type=='factor','n','s')
groups <- c(99999999)
type <- c('remove')
counter <- 1
for (i in 1:(length(col_type_simpler)-1)){
flag <- col_type_simpler[i+1]
if (flag ==col_type_simpler[i]){
counter <- counter +1
if (i +1 == length(col_type_simpler)){groups <- c(groups,counter)
type <- c(type,col_type_simpler[i+1])}
}
if (flag !=col_type_simpler[i]){
groups <- c(groups,counter)
type <- c(type,col_type_simpler[i])
counter <- 1
if (i +1 == length(col_type_simpler)){groups <- c(groups,counter)
type <- c(type,col_type_simpler[i+1])}
}}
groups <- groups[-1]
type <- type[-1]
if (length(groups )==1 ){
groups <- c(floor(groups/2),groups-floor(groups/2))
type <- rep(type[1],2)
}
# Imputation
final <-  imputeMFA(df,group = groups,type = type,ncp = ncp,method = 'Regularized')$completeObs
# adding 0_1 columns
if (col_0_1){
columns_with_missing <-  (as.data.frame(is.na(df))*1)[,percent_of_missing>0]
colnames(columns_with_missing) <- paste(colnames(columns_with_missing),'where',sep='_')
final <- cbind(final,columns_with_missing)
}
return(final)
}
missMDA_result_2 <- missMDA_MFA(df,col_type,percent_of_missing)
View(missMDA_MFA)
out_file <- 'LOG_PIPELINIE'
write(paste0('LOG',Sys.Date()),file = out_file)
for(id in datasets$ID[1:20]){
df_oml <- getOMLDataSet(id)
df_desc <- df_oml$desc
df <- df_oml$data
### Preprocessing step ###
#Columns to ignore according to tags
to_ignore <- df_desc$ignore.attribute
if(!is.na(to_ignore)){
df <- select(df, -all_of(to_ignore))
}
#Removing row ID column according to tags
row_id <- df_desc$row.id.attribute
if(!is.na(row_id)){
df <- select(df, -all_of(row_id))
}
#Data types
data_types_check <- sapply(df, check_type)
if(any(!data_types_check)){
wrong_columns <- colnames(df)[!data_types_check]
#Trying possible conversions
for(col in wrong_columns){
if(is.logical(df[,col]) | is.character(df[,col])){
df[,col] <- as.factor(df[,col])
}else{
warning(paste("Data type trouble ID: ", as.character(id)))
data_types_troubles <- c(data_types_troubles, id)
}
}
}
#Removing possible duplicate rows
df <- df[!duplicated(df), ]
#Removing constant columns
df <- remove_constant(df)
#Removing empty columns
df <- remove_empty(df, "cols")
#All to lowercase
df <- mutate_if(df, is.factor, function(x) factor(tolower(x)))
#Missing values in target variable
target <- df_oml$target.features
if(any(is.na(df[, target]))){
miss_in_target <- c(miss_in_target, id)
warning(paste("Missing values in target variable ID: ", as.character(id)))
}
##
### OUTPUT FILE LOCATION
##
col_type <- 1:ncol(df)
for ( i in col_type){
col_type[i] <- class(df[,i])
}
percent_of_missing  <- 1:ncol(df)
for ( i in percent_of_missing){
percent_of_missing[i] <- (sum(is.na(df[,i]))/length(df[,1]))*100
}
single_set_Pipeline(df,id,col_type,percent_of_missing,out_file_location = out_file,single_set = FALSE)
write(paste0('LOG',Sys.Date()),file = out_file)
for(id in datasets$ID[1:20]){
df_oml <- getOMLDataSet(id)
df_desc <- df_oml$desc
df <- df_oml$data
### Preprocessing step ###
#Columns to ignore according to tags
to_ignore <- df_desc$ignore.attribute
if(!is.na(to_ignore)){
df <- select(df, -all_of(to_ignore))
}
#Removing row ID column according to tags
row_id <- df_desc$row.id.attribute
if(!is.na(row_id)){
df <- select(df, -all_of(row_id))
}
#Data types
data_types_check <- sapply(df, check_type)
if(any(!data_types_check)){
wrong_columns <- colnames(df)[!data_types_check]
#Trying possible conversions
for(col in wrong_columns){
if(is.logical(df[,col]) | is.character(df[,col])){
df[,col] <- as.factor(df[,col])
}else{
warning(paste("Data type trouble ID: ", as.character(id)))
data_types_troubles <- c(data_types_troubles, id)
}
}
}
#Removing possible duplicate rows
df <- df[!duplicated(df), ]
#Removing constant columns
df <- remove_constant(df)
#Removing empty columns
df <- remove_empty(df, "cols")
#All to lowercase
df <- mutate_if(df, is.factor, function(x) factor(tolower(x)))
#Missing values in target variable
target <- df_oml$target.features
if(any(is.na(df[, target]))){
miss_in_target <- c(miss_in_target, id)
warning(paste("Missing values in target variable ID: ", as.character(id)))
}
##
### OUTPUT FILE LOCATION
##
col_type <- 1:ncol(df)
for ( i in col_type){
col_type[i] <- class(df[,i])
}
percent_of_missing  <- 1:ncol(df)
for ( i in percent_of_missing){
percent_of_missing[i] <- (sum(is.na(df[,i]))/length(df[,1]))*100
}
single_set_Pipeline(df,id,col_type,percent_of_missing,out_file_location = out_file,single_set = FALSE)
}
