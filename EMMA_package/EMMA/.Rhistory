vector <- (mtry_set[1]:ncol(df))
mtry_set[2] <- floor(length(vector)/4)
mtry_set[3] <- floor(2*length(vector)/4)
mtry_set[4] <- floor(3*length(vector)/4)
}
}
# If parallel=TRUE
parallelize <- 'no'
if (parallel){
parallelize <-  'variables'}
if (!is.null(cores)){
if(cores<=1){parallelize <- 'no'}}
if(!is.null(out_file)){
write('missForest',file = out_file,append = T)
}
tryCatch({
if (optimize){
# Grid search using mean OBBerror
best_params <-  c(-11,-11)
best_OBB <- 10
for (i in ntree_set)
{
for (j in mtry_set){
skip_to_next <- FALSE
tryCatch({
iteration <-  mean(missForest(df,maxiter = maxiter,ntree = i,mtry = j,parallelize=parallelize,maxnodes = maxnodes,verbose = verbose)$OOBerror)
if (iteration<best_OBB){
best_OBB <- iteration
best_params[1] <- i
best_params[2] <- j
}
}, error = function(e) { skip_to_next <<- TRUE})
if(skip_to_next) { next }
}
}
#fianl imputation
final <- missForest(df,maxiter = maxiter,maxnodes = maxnodes,ntree = best_params[1],mtry = best_params[2],parallelize=parallelize,verbose = verbose)$ximp
}
if (!optimize){
if (is.null(mtry)){
final <- missForest(df,maxiter = maxiter,ntree = ntree,maxnodes = maxnodes,mtry = floor(sqrt(ncol(df))),parallelize = parallelize,verbose = verbose)$ximp}
else{ final <- missForest(df,maxiter = maxiter,ntree = ntree,maxnodes = maxnodes,mtry = mtry,parallelize = parallelize,verbose = verbose)$ximp}
}
if(!is.null(out_file)){
write(c(best_params[1],best_params[2]),file = out_file,append = T)
write(' OK',file = out_file,append = T)
}
},error=function(e){
if(!is.null(out_file)){
write(as.character(e),file = out_file,append = T)
}
stop(e)
})
#adding 0_1_cols
if (col_0_1){
columns_with_missing <-  (as.data.frame(is.na(df))*1)[,percent_of_missing>0]
colnames(columns_with_missing) <- paste(colnames(columns_with_missing),'where',sep='_')
final <- cbind(final,columns_with_missing)
}
# turn off paralllel
if (parallel){
registerDoSEQ()
}
return(final)
}
#
#
test <- PipeOpmissForest$new()
graph =  test %>>% learner_po
glrn = GraphLearner$new(graph)
glrn$train(d)
resample(d, glrn, rsmp("cv"))
resample(d, glrn, rsmp("cv"))
#
#
test <- PipeOpMice$new()
graph =  test %>>% learner_po
glrn = GraphLearner$new(graph)
resample(d, glrn, rsmp("cv"))
View(dataset)
debugSource('~/Pulpit/Job_repo/EMMA/EMMA_package/EMMA/R/PipeOPmissForest.R', echo=TRUE)
source('~/Pulpit/Job_repo/EMMA/EMMA_package/EMMA/R/PipeOpMice.R', echo=TRUE)
#
#
test <- PipeOpmissForest$new()
#
#
test <- PipeOpmissForest$new()
graph =  test %>>% learner_po
glrn = GraphLearner$new(graph)
source('~/Pulpit/Job_repo/EMMA/EMMA_package/EMMA/R/PipeOpMice.R', echo=TRUE)
debugSource('~/Pulpit/Job_repo/EMMA/EMMA_package/EMMA/R/PipeOPmissForest.R', echo=TRUE)
debugSource('~/Pulpit/Job_repo/EMMA/EMMA_package/EMMA/R/PipeOPmissForest.R', echo=TRUE)
debugSource('~/Pulpit/Job_repo/EMMA/EMMA_package/EMMA/R/PipeOPmissForest.R', echo=TRUE)
self$data_imputed
test <- PipeOpmissForest$new()
graph =  test %>>% learner_po
glrn = GraphLearner$new(graph)
#glrn$train(d)
resample(d, glrn, rsmp("cv"))
#' missForest imputation
#'
#' @description This class create object implements autotune_missForest function for use in mlr3 pipelinies. Object can be created with \code{\link{autotune_missForest}} params.
#'
#'
#'
#' @import mlr3
#' @import mlr3pipelines
PipeOpmissForest <-  R6::R6Class("missForest_imputation",lock_objects=FALSE,
inherit = PipeOpImpute,  # inherit from PipeOp
public = list(
initialize = function(id = "imput_missForest", cores=NULL,ntree_set=c(100,200,500,1000),mtry_set=NULL,parallel=TRUE
,col_0_1=FALSE,mtry=NULL,ntree=100,optimize=FALSE,maxiter=20,maxnodes=NULL,out_file=NULL
) {
super$initialize(id,whole_task_dependent=TRUE,param_vals = list(cores =cores,ntree_set =ntree_set,mtry_set=mtry_set,parallel=parallel,
col_0_1=col_0_1,mtry=mtry,ntree=ntree,optimize=optimize,
maxiter=maxiter,maxnodes=maxnodes,out_file=out_file),
param_set= ParamSet$new(list(
'ntree_set'=ParamUty$new('ntree_set', default = c(100,200,500,1000), tags = 'missForest'),
'cores'=ParamUty$new('cores',default = NULL,tags='missForest'),
'mtry_set'=ParamUty$new('mtry_set',default = NULL,tags='missForest'),
'parallel'=ParamLgl$new('parallel',default = TRUE,tags = 'missForest'),
'col_0_1'=ParamLgl$new('col_0_1',default = F,tags='missForest'),
'mtry'=ParamUty$new('mtry',default = NULL,tags='missForest'),
'ntree'=ParamInt$new('ntree',lower = 10,upper = Inf,default = 100,tags='missForest'),
'optimize'=ParamLgl$new('optimize',default = FALSE,tags='missForest'),
'maxiter'=ParamInt$new('maxiter',lower = 5,upper = Inf,default = 20,tags='missForest'),
'maxnodes'=ParamUty$new('maxnodes',default = NULL,tags='missForest'),
'out_file'=ParamUty$new('out_file',default = NULL,tags = 'missForest')
)),
)
self$imputed <- FALSE
self$column_counter <- NULL
self$data_imputed <- NULL
},
train_imputer=function(feature, type, context){
imp_function <- function(data_to_impute){
data_to_impute <- as.data.frame(data_to_impute)
# prepering arguments for function
col_type <- 1:ncol(data_to_impute)
for (i in col_type){
col_type[i] <- class(data_to_impute[,i])
}
percent_of_missing <- 1:ncol(data_to_impute)
for (i in percent_of_missing){
percent_of_missing[i] <- (sum(is.na(data_to_impute[,i]))/length(data_to_impute[,1]))*100
}
col_miss <- colnames(data_to_impute)[percent_of_missing>0]
col_no_miss <- colnames(data_to_impute)[percent_of_missing==0]
data_imputed <- autotune_missForest(data_to_impute,percent_of_missing = percent_of_missing,cores = self$param_set$values$cores,
ntree_set = self$param_set$values$ntree_set,mtry_set = self$param_set$values$mtry_set,
parallel = self$param_set$values$parallel,
col_0_1 = self$param_set$values$col_0_1,optimize = self$param_set$values$optimize,
ntree = self$param_set$values$ntree,mtry = self$param_set$values$mtry,
maxiter=self$param_set$values$maxiter,maxnodes=self$param_set$values$maxnodes,verbose = F,
out_file =self$param_set$values$out_file)
return(data_imputed)
}
self$imputed_predict <- TRUE
self$flag <- 'train'
if(!self$imputed){
self$column_counter <- ncol(context)+1
self$imputed <- TRUE
data_to_impute <- cbind(feature,context)
self$data_imputed <- imp_function(data_to_impute)
colnames(self$data_imputed) <- self$state$context_cols
}
if(self$imputed){
self$column_counter <- self$column_counter -1
}
if  (self$column_counter==0){
self$imputed <- FALSE
}
self$train_s <- TRUE
return(NULL)
},
impute=function(feature, type, model, context){
imp_function <- function(data_to_impute){
data_to_impute <- as.data.frame(data_to_impute)
# prepering arguments for function
col_type <- 1:ncol(data_to_impute)
for (i in col_type){
col_type[i] <- class(data_to_impute[,i])
}
percent_of_missing <- 1:ncol(data_to_impute)
for (i in percent_of_missing){
percent_of_missing[i] <- (sum(is.na(data_to_impute[,i]))/length(data_to_impute[,1]))*100
}
col_miss <- colnames(data_to_impute)[percent_of_missing>0]
col_no_miss <- colnames(data_to_impute)[percent_of_missing==0]
data_imputed <- autotune_missForest(data_to_impute,percent_of_missing = percent_of_missing,cores = self$param_set$values$cores,
ntree_set = self$param_set$values$ntree_set,mtry_set = self$param_set$values$mtry_set,
parallel = self$param_set$values$parallel,
col_0_1 = self$param_set$values$col_0_1,optimize = self$param_set$values$optimize,
ntree = self$param_set$values$ntree,mtry = self$param_set$values$mtry,
maxiter=self$param_set$values$maxiter,maxnodes=self$param_set$values$maxnodes,verbose = F,
out_file =self$param_set$values$out_file)
return(data_imputed)
}
if (self$imputed){
feature <- self$data_imputed[,setdiff(colnames(self$data_imputed),colnames(context))]
}
if((nrow(self$data_imputed)!=nrow(context) | !self$train_s) & self$flag=='train'){
self$imputed_predict <- FALSE
self$flag <- 'predict'
}
if(!self$imputed_predict){
data_to_impute <- cbind(feature,context)
self$data_imputed <- imp_function(data_to_impute)
colnames(self$data_imputed) <- self$state$context_cols
self$imputed_predict <- TRUE
}
if (self$imputed_predict & self$flag=='predict' ){
feature <- self$data_imputed[,setdiff(colnames(self$data_imputed),colnames(context))]
}
if(self$column_counter == 0 & self$flag=='train'){
feature <- self$data_imputed[,setdiff(colnames(self$data_imputed),colnames(context))]
self$flag=='predict'
self$imputed_predict <- FALSE
}
self$train_s <- FALSE
return(feature)
}
)
)
mlr_pipeops$add("missForest_imputation", PipeOpmissForest)
test <- PipeOpmissForest$new()
graph =  test %>>% learner_po
glrn = GraphLearner$new(graph)
#glrn$train(d)
resample(d, glrn, rsmp("cv"))
PipeOpmissForest <-  R6::R6Class("missForest_imputation",lock_objects=FALSE,
inherit = PipeOpImpute,  # inherit from PipeOp
public = list(
initialize = function(id = "imput_missForest", cores=NULL,ntree_set=c(100,200,500,1000),mtry_set=NULL,parallel=TRUE
,col_0_1=FALSE,mtry=NULL,ntree=100,optimize=FALSE,maxiter=20,maxnodes=NULL,out_file=NULL
) {
super$initialize(id,whole_task_dependent=TRUE,param_vals = list(cores =cores,ntree_set =ntree_set,mtry_set=mtry_set,parallel=parallel,
col_0_1=col_0_1,mtry=mtry,ntree=ntree,optimize=optimize,
maxiter=maxiter,maxnodes=maxnodes,out_file=out_file),
param_set= ParamSet$new(list(
'ntree_set'=ParamUty$new('ntree_set', default = c(100,200,500,1000), tags = 'missForest'),
'cores'=ParamUty$new('cores',default = NULL,tags='missForest'),
'mtry_set'=ParamUty$new('mtry_set',default = NULL,tags='missForest'),
'parallel'=ParamLgl$new('parallel',default = TRUE,tags = 'missForest'),
'col_0_1'=ParamLgl$new('col_0_1',default = F,tags='missForest'),
'mtry'=ParamUty$new('mtry',default = NULL,tags='missForest'),
'ntree'=ParamInt$new('ntree',lower = 10,upper = Inf,default = 100,tags='missForest'),
'optimize'=ParamLgl$new('optimize',default = FALSE,tags='missForest'),
'maxiter'=ParamInt$new('maxiter',lower = 5,upper = Inf,default = 20,tags='missForest'),
'maxnodes'=ParamUty$new('maxnodes',default = NULL,tags='missForest'),
'out_file'=ParamUty$new('out_file',default = NULL,tags = 'missForest')
)),
)
self$imputed <- FALSE
self$column_counter <- NULL
self$data_imputed <- NULL
},
train_imputer=function(feature, type, context){
imp_function <- function(data_to_impute){
data_to_impute <- as.data.frame(data_to_impute)
# prepering arguments for function
col_type <- 1:ncol(data_to_impute)
for (i in col_type){
col_type[i] <- class(data_to_impute[,i])
}
percent_of_missing <- 1:ncol(data_to_impute)
for (i in percent_of_missing){
percent_of_missing[i] <- (sum(is.na(data_to_impute[,i]))/length(data_to_impute[,1]))*100
}
col_miss <- colnames(data_to_impute)[percent_of_missing>0]
col_no_miss <- colnames(data_to_impute)[percent_of_missing==0]
data_imputed <- autotune_missForest(data_to_impute,percent_of_missing = percent_of_missing,cores = self$param_set$values$cores,
ntree_set = self$param_set$values$ntree_set,mtry_set = self$param_set$values$mtry_set,
parallel = self$param_set$values$parallel,
col_0_1 = self$param_set$values$col_0_1,optimize = self$param_set$values$optimize,
ntree = self$param_set$values$ntree,mtry = self$param_set$values$mtry,
maxiter=self$param_set$values$maxiter,maxnodes=self$param_set$values$maxnodes,verbose = F,
out_file =self$param_set$values$out_file)
return(data_imputed)
}
self$imputed_predict <- TRUE
self$flag <- 'train'
if(!self$imputed){
self$column_counter <- ncol(context)+1
self$imputed <- TRUE
data_to_impute <- cbind(feature,context)
self$data_imputed <- imp_function(data_to_impute)
colnames(self$data_imputed) <- self$state$context_cols
}
if(self$imputed){
self$column_counter <- self$column_counter -1
}
if  (self$column_counter==0){
self$imputed <- FALSE
}
self$train_s <- TRUE
return(NULL)
},
impute=function(feature, type, model, context){
imp_function <- function(data_to_impute){
data_to_impute <- as.data.frame(data_to_impute)
# prepering arguments for function
col_type <- 1:ncol(data_to_impute)
for (i in col_type){
col_type[i] <- class(data_to_impute[,i])
}
percent_of_missing <- 1:ncol(data_to_impute)
for (i in percent_of_missing){
percent_of_missing[i] <- (sum(is.na(data_to_impute[,i]))/length(data_to_impute[,1]))*100
}
col_miss <- colnames(data_to_impute)[percent_of_missing>0]
col_no_miss <- colnames(data_to_impute)[percent_of_missing==0]
data_imputed <- autotune_missForest(data_to_impute,percent_of_missing = percent_of_missing,cores = self$param_set$values$cores,
ntree_set = self$param_set$values$ntree_set,mtry_set = self$param_set$values$mtry_set,
parallel = self$param_set$values$parallel,
col_0_1 = self$param_set$values$col_0_1,optimize = self$param_set$values$optimize,
ntree = self$param_set$values$ntree,mtry = self$param_set$values$mtry,
maxiter=self$param_set$values$maxiter,maxnodes=self$param_set$values$maxnodes,verbose = F,
out_file =self$param_set$values$out_file)
return(data_imputed)
}
if (self$imputed){
feature <- self$data_imputed[,setdiff(colnames(self$data_imputed),colnames(context))]
}
if((nrow(self$data_imputed)!=nrow(context) | !self$train_s) & self$flag=='train'){
self$imputed_predict <- FALSE
self$flag <- 'predict'
}
if(!self$imputed_predict){
data_to_impute <- cbind(feature,context)
self$data_imputed <- imp_function(data_to_impute)
colnames(self$data_imputed) <- self$state$context_cols
self$imputed_predict <- TRUE
}
if (self$imputed_predict & self$flag=='predict' ){
feature <- self$data_imputed[,setdiff(colnames(self$data_imputed),colnames(context))]
}
if(self$column_counter == 0 & self$flag=='train'){
feature <- self$data_imputed[,setdiff(colnames(self$data_imputed),colnames(context))]
self$flag=='predict'
self$imputed_predict <- FALSE
}
self$train_s <- FALSE
return(feature)
}
)
)
mlr_pipeops$add("missForest_imputation", PipeOpmissForest)
test <- PipeOpmissForest$new()
graph =  test %>>% learner_po
glrn = GraphLearner$new(graph)
#glrn$train(d)
resample(d, glrn, rsmp("cv"))
test <- PipeOpmissForest$new()
graph =  test %>>% learner_po
glrn = GraphLearner$new(graph)
#glrn$train(d)
resample(d, glrn, rsmp("cv"))
debugSource('~/Pulpit/Job_repo/EMMA/EMMA_package/EMMA/R/PipeOPmissForest.R', echo=TRUE)
debugSource('~/Pulpit/Job_repo/EMMA/EMMA_package/EMMA/R/PipeOPmissForest.R', echo=TRUE)
View(context)
View(data_to_impute)
View(data_to_impute)
self$data_imputed
View(data_to_impute)
self$data_imputed[,setdiff(colnames(self$data_imputed),colnames(context))]
debugSource('~/Pulpit/Job_repo/EMMA/EMMA_package/EMMA/R/PipeOPmissForest.R', echo=TRUE)
debugSource('~/Pulpit/Job_repo/EMMA/EMMA_package/EMMA/R/PipeOPmissForest.R', echo=TRUE)
feature
self$data_imputed[,setdiff(colnames(self$data_imputed),colnames(context))]
setdiff(colnames(self$data_imputed)
View(context)
View(context)
colnames(self$data_imputed)
View(data_to_impute)
setdiff(colnames(self$data_imputed),colnames(context))
ifelse(colnames(self$data_imputed)%in%colnames(context))
ifelse(colnames(self$data_imputed)%in%colnames(context),FALSE,TRUE)
colnames(self$data_imputed)[ifelse(colnames(self$data_imputed)%in%colnames(context),FALSE,TRUE)]
self$data_imputed <- imp_function(data_to_impute)
self$data_imputed
setdiff(self$state$context_cols,colnames(context))
PipeOpmissForest <-  R6::R6Class("missForest_imputation",lock_objects=FALSE,
inherit = PipeOpImpute,  # inherit from PipeOp
public = list(
initialize = function(id = "imput_missForest", cores=NULL,ntree_set=c(100,200,500,1000),mtry_set=NULL,parallel=TRUE
,col_0_1=FALSE,mtry=NULL,ntree=100,optimize=FALSE,maxiter=20,maxnodes=NULL,out_file=NULL
) {
super$initialize(id,whole_task_dependent=TRUE,param_vals = list(cores =cores,ntree_set =ntree_set,mtry_set=mtry_set,parallel=parallel,
col_0_1=col_0_1,mtry=mtry,ntree=ntree,optimize=optimize,
maxiter=maxiter,maxnodes=maxnodes,out_file=out_file),
param_set= ParamSet$new(list(
'ntree_set'=ParamUty$new('ntree_set', default = c(100,200,500,1000), tags = 'missForest'),
'cores'=ParamUty$new('cores',default = NULL,tags='missForest'),
'mtry_set'=ParamUty$new('mtry_set',default = NULL,tags='missForest'),
'parallel'=ParamLgl$new('parallel',default = TRUE,tags = 'missForest'),
'col_0_1'=ParamLgl$new('col_0_1',default = F,tags='missForest'),
'mtry'=ParamUty$new('mtry',default = NULL,tags='missForest'),
'ntree'=ParamInt$new('ntree',lower = 10,upper = Inf,default = 100,tags='missForest'),
'optimize'=ParamLgl$new('optimize',default = FALSE,tags='missForest'),
'maxiter'=ParamInt$new('maxiter',lower = 5,upper = Inf,default = 20,tags='missForest'),
'maxnodes'=ParamUty$new('maxnodes',default = NULL,tags='missForest'),
'out_file'=ParamUty$new('out_file',default = NULL,tags = 'missForest')
)),
)
self$imputed <- FALSE
self$column_counter <- NULL
self$data_imputed <- NULL
},
train_imputer=function(feature, type, context){
imp_function <- function(data_to_impute){
data_to_impute <- as.data.frame(data_to_impute)
# prepering arguments for function
col_type <- 1:ncol(data_to_impute)
for (i in col_type){
col_type[i] <- class(data_to_impute[,i])
}
percent_of_missing <- 1:ncol(data_to_impute)
for (i in percent_of_missing){
percent_of_missing[i] <- (sum(is.na(data_to_impute[,i]))/length(data_to_impute[,1]))*100
}
col_miss <- colnames(data_to_impute)[percent_of_missing>0]
col_no_miss <- colnames(data_to_impute)[percent_of_missing==0]
data_imputed <- autotune_missForest(data_to_impute,percent_of_missing = percent_of_missing,cores = self$param_set$values$cores,
ntree_set = self$param_set$values$ntree_set,mtry_set = self$param_set$values$mtry_set,
parallel = self$param_set$values$parallel,
col_0_1 = self$param_set$values$col_0_1,optimize = self$param_set$values$optimize,
ntree = self$param_set$values$ntree,mtry = self$param_set$values$mtry,
maxiter=self$param_set$values$maxiter,maxnodes=self$param_set$values$maxnodes,verbose = F,
out_file =self$param_set$values$out_file)
return(data_imputed)
}
self$imputed_predict <- TRUE
self$flag <- 'train'
if(!self$imputed){
self$column_counter <- ncol(context)+1
self$imputed <- TRUE
data_to_impute <- cbind(feature,context)
self$data_imputed <- imp_function(data_to_impute)
colnames(self$data_imputed) <- self$state$context_cols
}
if(self$imputed){
self$column_counter <- self$column_counter -1
}
if  (self$column_counter==0){
self$imputed <- FALSE
}
self$train_s <- TRUE
return(NULL)
},
impute=function(feature, type, model, context){
imp_function <- function(data_to_impute){
data_to_impute <- as.data.frame(data_to_impute)
# prepering arguments for function
col_type <- 1:ncol(data_to_impute)
for (i in col_type){
col_type[i] <- class(data_to_impute[,i])
}
percent_of_missing <- 1:ncol(data_to_impute)
for (i in percent_of_missing){
percent_of_missing[i] <- (sum(is.na(data_to_impute[,i]))/length(data_to_impute[,1]))*100
}
col_miss <- colnames(data_to_impute)[percent_of_missing>0]
col_no_miss <- colnames(data_to_impute)[percent_of_missing==0]
data_imputed <- autotune_missForest(data_to_impute,percent_of_missing = percent_of_missing,cores = self$param_set$values$cores,
ntree_set = self$param_set$values$ntree_set,mtry_set = self$param_set$values$mtry_set,
parallel = self$param_set$values$parallel,
col_0_1 = self$param_set$values$col_0_1,optimize = self$param_set$values$optimize,
ntree = self$param_set$values$ntree,mtry = self$param_set$values$mtry,
maxiter=self$param_set$values$maxiter,maxnodes=self$param_set$values$maxnodes,verbose = F,
out_file =self$param_set$values$out_file)
return(data_imputed)
}
if (self$imputed){
feature <- self$data_imputed[,setdiff(colnames(self$data_imputed),colnames(context))]
}
if((nrow(self$data_imputed)!=nrow(context) | !self$train_s) & self$flag=='train'){
self$imputed_predict <- FALSE
self$flag <- 'predict'
}
if(!self$imputed_predict){
data_to_impute <- cbind(feature,context)
self$data_imputed <- imp_function(data_to_impute)
colnames(self$data_imputed)[1] <- setdiff(self$state$context_cols,colnames(context))
self$imputed_predict <- TRUE
}
if (self$imputed_predict & self$flag=='predict' ){
feature <- self$data_imputed[,setdiff(colnames(self$data_imputed),colnames(context))]
}
if(self$column_counter == 0 & self$flag=='train'){
feature <- self$data_imputed[,setdiff(colnames(self$data_imputed),colnames(context))]
self$flag=='predict'
self$imputed_predict <- FALSE
}
self$train_s <- FALSE
return(feature)
}
)
)
test <- PipeOpmissForest$new()
graph =  test %>>% learner_po
glrn = GraphLearner$new(graph)
#glrn$train(d)
resample(d, glrn, rsmp("cv"))
test <- PipeOpmissForest$new()
graph =  test %>>% learner_po
glrn = GraphLearner$new(graph)
#glrn$train(d)
resample(d, glrn, rsmp("cv"))
document()
library(EMMA)
