##   if (!identical(casepri,NULL)) {
##     #Error code: 17
##     #Case prior must be in a matrix
##     if (!is.matrix(casepri)) {
##       error.code<-17
##       error.mess<-paste("The case priors should be in a martix form.")
##       return(list(code=error.code,mess=error.mess))
##     }
##     #Error code: 18
##     #CS must be specified with case priors
##     if (identical(cs,NULL)) {
##       error.code<-18
##       error.mess<-paste("The cross-sectional variable must be set in order to use case priors.")
##       return(list(code=error.code,mess=error.mess))
##     }
##     #Error code: 19
##     #Case priors have the wrong dimensions
##     if (sum(dim(casepri) == c(length(unique(data[,cs])),length(unique(data[,cs])))) != 2) {
##       error.code<-19
##       error.mess<-paste("The case priors have the wrong dimensions.  It should \n",
##                            "have rows and columns equal to the number of cases.")
##       return(list(code=error.code,mess=error.mess))
##     }
##     #Error code: 20
##     #Case prior values are out of bounds
##     if (all(casepri != 0,casepri!=1,casepri!=2,casepri!=3)) {
##       error.code<-20
##       error.mess<-paste("The case priors can only have values 0, 1, 2, or 3.")
##       return(list(code=error.code,mess=error.mess))
##     }
##   }
#check polynomials
if (!identical(polytime,NULL)) {
#Error code: 21
#Polynomials of time are longer than one integer
if (length(polytime) > 1) {
error.code<-21
error.mess<-paste("The polynomials of time setting is greater than one integer.")
return(list(code=error.code,mess=error.mess))
}
if (!is.numeric(polytime)) {
error.code<-22
error.mess<-paste("The setting for polytime is not a number.")
return(list(code=error.code,mess=error.mess))
}
if ((polytime %% 1) != 0) {
error.code<-23
error.mess<-paste("The number of polynomial terms to include for time (polytime) must be an integer.")
return(list(code=error.code,mess=error.mess))
}
if (any(polytime > 3,polytime < 0)) {
error.code<-24
error.mess<-paste("The number of polynomial terms to include must be between 1 and 3.")
return(list(code=error.code,mess=error.mess))
}
if (identical(ts,NULL)) {
error.code<-25
error.mess<-paste("You have set polynomials of time without setting the time series variable.")
return(list(code=error.code,mess=error.mess))
}
if (all(!intercs,identical(polytime,0))) {
warning(paste("You've set the polynomials of time to zero with no interaction with \n",
"the cross-sectional variable.  This has no effect on the imputation."))
}
}
if (!identical(splinetime,NULL)) {
#Error code: 54
#Spline of time are longer than one integer
if (length(polytime) > 1) {
error.code<-54
error.mess<-paste("The spline of time setting is greater than one integer.")
return(list(code=error.code,mess=error.mess))
}
if (!is.numeric(splinetime)) {
error.code<-55
error.mess<-paste("The setting for splinetime is not a number.")
return(list(code=error.code,mess=error.mess))
}
if ((splinetime %% 1) != 0) {
error.code<-56
error.mess<-paste("The number of spline degrees of freedom to include for time (splinetime) must be an integer.")
return(list(code=error.code,mess=error.mess))
}
if (any(splinetime > 6,splinetime < 0)) {
error.code<-57
error.mess<-paste("The number of spline degrees of freedom to include must be between 0 and 6.")
return(list(code=error.code,mess=error.mess))
}
if (identical(ts,NULL)) {
error.code<-58
error.mess<-paste("You have set splines of time without setting the time series variable.")
return(list(code=error.code,mess=error.mess))
}
if (all(!intercs,identical(polytime,0))) {
warning(paste("You've set the spline of time to zero with no interaction with \n",
"the cross-sectional variable.  This has no effect on the imputation."))
}
}
#checks for intercs
if (identical(intercs,TRUE)) {
if (identical(cs,NULL)) {
error.code<-27
error.mess<-paste("You have indicated an interaction with the cross section \n",
"without setting the cross section variable.")
return(list(code=error.code,mess=error.mess))
}
if (length(unique(x[,cs])) > (1/3)*(AMn)) {
error.code<-28
error.mess<-paste("There are too many cross-sections in the data to use an \n",
"interaction between polynomial of time and the cross-section.")
return(list(code=error.code,mess=error.mess))
}
if (sum(is.na(x[,cs])) > 0) {
error.code <- 60
error.mess <-
paste("There are missing values in the 'cs' variable.")
return(list(code=error.code,mess=error.mess))
}
}
#Error codes: 29-31
#logical variable errors
interout<-logiccheck(intercs,"cross section interaction")
if (!identical(interout,0))
return(list(code=(28+interout[[1]]),mess=interout[[2]]))
#p2sout<-logiccheck(p2s,"print to screen")
#if (!identical(p2sout,0))
#  return(list(code=(p2sout[[1]]+28),mess=p2sout[[2]]))
frout<-logiccheck(frontend,"frontend")
if (!identical(frout,0))
return(list(code=(frout[[1]]+28),mess=frout[[2]]))
collout<-logiccheck(collect,"archive")
if (!identical(collout,0))
return(list(code=(collout[[1]]+28),mess=collout[[2]]))
#Error code: 32
#Transformations must be mutually exclusive
if (length(unique(c(logs,sqrts,lgstc,noms,ords,idvars))) != length(c(logs,sqrts,lgstc,noms,ords,idvars))) {
error.code<-32
error.mess<-paste("Transfomations must be mutually exclusive, so one \n",
"variable can only be assigned one transformation.  You have the \n",
"same variable designated for two transformations.")
return(list(code=error.code,mess=error.mess))
}
#Error code: 33
#ts/cs variables can't be transformed
if (any(unique(c(logs,sqrts,lgstc,noms,ords,idvars)) == ts,unique(c(logs,sqrts,lgstc,noms,ords,idvars)) == cs)) {
error.code<-33
error.mess<-paste("The time series and cross sectional variables cannot be transformed.")
return(list(code=error.code,mess=error.mess))
}
#Error code: 35
#tolerance must be greater than zero
if (tolerance <= 0) {
error.code<-35
error.mess<-paste("The tolerance option must be greater than zero.")
return(list(code=error.code,mess=error.mess))
}
#check nominals
if (!identical(noms,NULL)) {
for (i in noms) {
#Error code: 36
#too many levels on noms
if (length(unique(na.omit(x[,i]))) > (1/3)*(AMn)) {
bad.var <- colnames(x)[i]
if (is.null(bad.var)) bad.var <- i
error.code<-36
error.mess<-paste("The number of categories in the nominal variable \'",bad.var,"\' is greater than one-third of the observations.", sep = "")
return(list(code=error.code,mess=error.mess))
}
if (length(unique(na.omit(x[,i]))) > 10)
warning("\n\nThe number of categories in one of the variables marked nominal has greater than 10 categories. Check nominal specification.\n\n")
if (all(i==cs,intercs==TRUE)) {
noms<-noms[noms!=i]
warning("The cross sectional variable was set as a nominal variable.  Its nominal status has been dropped.")
}
}
}
if (is.null(c(noms,ords,idvars,cs)))
fact <- c(1:AMp)
else
fact <- -c(noms,ords,idvars,cs)
if (is.null(c(cs,idvars)))
idcheck <- c(1:AMp)
else
idcheck <- -c(cs,idvars)
##Error code: 37
##factors out of the noms,ids,ords,cs
if (is.data.frame(x)) {
if (length(x[,fact])) {
if (sum(sapply(x[,fact],is.factor))) {
bad.var <- colnames(x[,fact])[sapply(x[,fact],is.factor)]
if (is.null(bad.var))
bad.var <- setdiff(which(sapply(x,is.factor)), -fact)
bad.var <- paste(bad.var, collapse = ", ")
error.code<-37
error.mess<-paste("The following variable(s) are 'factors': ",
bad.var,
"You may have wanted to set this as a ID variable to remove it",
"from the imputation model or as an ordinal or nominal",
"variable to be imputed.  Please set it as either and",
"try again.", sep = "\n")
return(list(code=error.code,mess=error.mess))
}
if (sum(sapply(x[,fact],is.ordered))) {
bad.var <- colnames(x[,fact])[sapply(x[,fact],is.ordered)]
if (is.null(bad.var))
bad.var <- setdiff(which(sapply(x,is.ordered)), -fact)
bad.var <- paste(bad.var, collapse = ", ")
error.code<-37
error.mess<-paste("The following variable(s) are 'factors': ",
bad.var,
"You may have wanted to set this as a ID variable to remove it",
"from the imputation model or as an ordinal or nominal",
"variable to be imputed.  Please set it as either and",
"try again.", sep = "\n")
return(list(code=error.code,mess=error.mess))
}
if (sum(sapply(x[,fact],is.character))) {
bad.var <- colnames(x[,fact])[sapply(x[,fact],is.character)]
if (is.null(bad.var))
bad.var <- setdiff(which(sapply(x,is.character)), -fact)
bad.var <- paste(bad.var, collapse = ", ")
error.code<-38
error.mess<-paste("The following variable(s) are characters: ",
paste("\t",bad.var),
"You may have wanted to set this as a ID variable to remove it",
"from the imputation model or as an ordinal or nominal",
"variable to be imputed.  Please set it as either and",
"try again.", sep = "\n")
return(list(code=error.code,mess=error.mess))
}
}
} else {
if (!is.numeric(x)) {
error.code <- 38
error.mess <- paste("The \'x\' matrix is not numeric.")
return(list(code=error.code,mess=error.mess))
}
}
#Error code: 39
#No missing observation
if (!any(is.na(x[,idcheck,drop=FALSE])) & is.null(overimp)) {
error.code<-39
error.mess<-paste("Your data has no missing values.  Make sure the code for \n",
"missing data is set to the code for R, which is NA.")
return(list(code=error.code,mess=error.mess))
}
#Error code: 40
#lags require ts
if (!is.null(lags)) {
if (is.null(ts)) {
error.code<-40
error.mess<-paste("You need to specify the time variable in order to create lags.")
return(list(code=error.code,mess=error.mess))
}
}
#Error code: 41
#leads require ts
if (!is.null(leads)) {
if (is.null(ts)) {
error.code<-41
error.mess<-paste("You need to specify the time variable in order to create leads.")
return(list(code=error.code,mess=error.mess))
}
}
#Error code: 42
#Only 1 column of data
if (AMp==1) {
error.code<-42
error.mess<-paste("There is only 1 column of data. Cannot impute.")
return(list(code=error.code,mess=error.mess))
}
## catch problems when the only other variable is an unused
## cross-section.
if (!isTRUE(intercs) & ncol(x[,idcheck, drop = FALSE]) == 1) {
error.code<-42
error.mess<-paste("There is only 1 column of data. Cannot impute.")
return(list(code=error.code,mess=error.mess))
}
ts.nulls <- is.null(polytime) & is.null(splinetime)
ts.zeros <- (polytime == 0) & (splinetime == 0)
if (!isTRUE(polytime > 0) & !isTRUE(splinetime > 0)) {
if (!isTRUE(intercs) & !is.null(ts)) {
if (ncol(x[,-c(ts,cs,idvars), drop = FALSE]) == 1) {
error.code<-61
error.mess<-paste("There is only 1 column of data after removing the ts, cs and idvars. Cannot impute without adding polytime.")
return(list(code=error.code,mess=error.mess))
}
}
}
#Error code: 43
#Variable that doesn't vary
## note that this will allow the rare case that a user only has
## variation in a variable when all of the other variables are missing
## in addition to having no variation in the listwise deleted
## dataset. Our starting value function should be robust to this.
num.nonmissing <- function(obj) length(unique(na.omit(obj)))
if (is.data.frame(x)) {
non.vary <- sapply(x[,idcheck, drop = FALSE], num.nonmissing)
} else {
non.vary <- apply(x[,idcheck, drop = FALSE], 2, num.nonmissing)
}
if (sum(non.vary == 1)) {
non.names <- colnames(x[,idcheck])[non.vary == 1]
if (is.null(non.names)) {
hold <- rep(-1, ncol(x))
hold[-idcheck] <- non.vary
non.names <- which(hold == 0)
}
non.names <- paste(non.names, collapse = ", ")
error.code<-43
error.mess<-paste("You have a variable in your dataset that does not vary.  Please remove this variable. Variables that do not vary: ", non.names)
return(list(code=error.code,mess=error.mess))
}
##   } else {
##     if (nrow(na.omit(x)) > 1) {
##       if (any(diag(var(x[,idcheck],na.rm=TRUE))==0)) {
##         error.code<-43
##         error.mess<-paste("You have a variable in your dataset that does not vary.  Please remove this variable.")
##         return(list(code=error.code,mess=error.mess))
##       }
##     } else {
##       for (i in 1:ncol(x[,idcheck])) {
##         if (var(x[,i],na.rm=TRUE) == 0) {
##           error.code<-43
##           error.mess<-paste("You have a variable in your dataset that does not vary.  Please remove this variable.")
##           return(list(code=error.code,mess=error.mess))
##         }
##       }
##     }
##   }
#checks for ordinals
if (!is.null(ords)) {
for (i in ords) {
#Error code: 44
# Ordinal variable with non-integers (factors work by design, and they're
# harder to check
if (!is.factor(x[,i])) {
if (any(unique(na.omit(x[,i])) %% 1 != 0 )) {
non.ints <- colnames(x)[i]
if (is.null(non.ints)) non.ints <- i
error.code<-44
error.mess<-paste("You have designated the variable \'",non.ints,
"\' as ordinal when it has non-integer values.",
sep = "")
return(list(code=error.code,mess=error.mess))
}
}
}
}
##   #checks for outname
##   if (write.out==TRUE) {
##     if (!is.character(outname)) {
##       outname<-"outdata"
##       warning("The output filename (outname) was not a character.  It has been set it
## its default 'outdata' in the working directory.")
##     }
##     #Error code: 45
##     #output file errors
##     outtest<-try(write.csv("test",file=paste(outname,"1.csv",sep="")),silent=TRUE)
##     if (inherits(outtest,"try-error")) {
##       error.code<-45
##       error.mess<-paste("R cannot write to the outname you have specified.  Please
## check","that the directory exists and that you have permission to write.",sep="\n")
##       return(list(code=error.code,mess=error.mess))
##     }
##     tmpdir<- strsplit(paste(outname,"1.csv",sep=""),.Platform$file.sep)
##     am.dir <- tmpdir[[1]][1]
##     if (length(tmpdir[[1]]) > 1)
##       for (i in 2:(length(tmpdir[[1]])))
##         am.dir <- file.path(am.dir, tmpdir[[1]][i])
##     file.remove(am.dir)
##   }
#  if (xor(!identical(means,NULL),!identical(sds,NULL))) {
#    means<-NULL
#    sds<-NULL
#    warning("Both the means and the SDs have to be set in order to use observational priors.  The priors have been removed from the analysis.")
#  }
#  if (sum(!identical(mins,NULL),!identical(maxs,NULL),!identical(conf,NULL)) != 3 &&
#        sum(!identical(mins,NULL),!identical(maxs,NULL),!identical(conf,NULL)) != 0) {
#    mins<-NULL
#    maxs<-NULL
#    conf<-NULL
#    warning("Not all of the range parameters were set for the observational priors.  They have been removed.")
#  }
#checks of m
if (!is.numeric(m)) {
m<-5
warning("The number of imputations ('m') was a non-numeric.  The value was changed to the default.")
}
if ((m %% 1) != 0) {
m<-5
warning("The number of imputation ('m') was not an integer.  The value was changed to the default (5).")
}
if (m<=0) {
m<-5
warning("The number of imputations ('m') must be greater than 0.  The value was changed to the default (5).")
}
# checks for bounds
if (!is.null(bounds)) {
b.size <- is.matrix(bounds) && ncol(bounds)==3 && nrow(bounds) > 0
b.cols <- sum(bounds[,1] %in% c(1:AMp)) == nrow(bounds)
maxint <- max.resample > 0 && (max.resample %% 1)==0
# Error 50:
# wrong sized bounds matrix
if (!b.size) {
error.code<-50
error.mess<-paste("The bounds argument is a three-column matrix.")
return(list(code=error.code,mess=error.mess))
}
# Error 51:
# nonexistant columns in bounds.
if (!b.cols) {
error.code<-51
error.mess<-paste("One of the bounds is on a non-existant column.")
return(list(code=error.code,mess=error.mess))
}
# Error 52:
# max.resample needs to be positive integer.
if (!maxint) {
error.code<-52
error.mess<-paste("The max.resample argument needs to be a positive integer.")
return(list(code=error.code,mess=error.mess))
}
}
if (!is.null(overimp)) {
o.num  <- is.numeric(overimp)
o.size <- (is.matrix(overimp) & ncol(overimp) == 2) | length(overimp) == 2
o.cols <- all(unique(overimp[,2]) %in% 1:ncol(x))
o.rows <- all(unique(overimp[,1]) %in% 1:nrow(x))
## Error 53:
## overimp not numeric
if (!o.num | !o.size) {
error.code <- 53
error.mess <- "The overimp matrix needs to be a two-column numeric matrix."
return(list(code=error.code,mess=error.mess))
}
## Error 54:
## overimp out of range
if (!o.rows | !o.cols) {
error.code <- 54
error.mess <- "A row/column pair in overimp is outside the range of the data."
return(list(code=error.code,mess=error.mess))
}
}
if (is.data.frame(x)) {
is.posix <- function(x) inherits(x, c("POSIXt", "POSIXct", "POSIXlt"))
posix.check <- sapply(x, is.posix)
if (any(is.na(x[, posix.check]))) {
stop("NA in POSIXt variable: remove or convert to numeric")
}
}
if (!is.null(emburn)) {
if (length(emburn) != 2) {
stop("emburn must be length 2")
}
}
if (!is.null(boot.type)) {
if (!(boot.type %in% c("ordinary", "none"))) {
stop("boot.type must be either 'ordinary' or 'none'")
}
}
if (is.data.frame(x)) {
if (sum(sapply(x, length) == 0)) {
bad.var <- colnames(x)[sapply(x,length) == 0]
if (is.null(bad.var))
bad.var <- which(sapply(x,length) == 0)
bad.var <- paste(bad.var, collapse = ", ")
error.code <- 53
error.mess<-paste("The variable(s)",bad.var,"have length 0 in the data frame. Try removing these variables or reimporting the data.")
return(list(code=error.code,mess=error.mess))
}
}
if (nrow(na.omit(x[,idcheck,drop=FALSE])) > ncol(x[,idcheck,drop=FALSE])) {
if (is.data.frame(x)) {
lmcheck <- lm(I(rnorm(AMn))~ ., data = x[,idcheck, drop = FALSE])
} else {
lmcheck <- lm(I(rnorm(AMn))~ ., data = as.data.frame(x[,idcheck, drop = FALSE]))
}
if (any(is.na(coef(lmcheck)))) {
bad.var <- names(coef(lmcheck))[which(is.na(coef(lmcheck)))]
if (length(bad.var) == 1) {
warning(paste("The variable", bad.var, "is perfectly collinear with another variable in the data.\n"))
} else {
bad.var <- paste(bad.var, collapse = ", ")
warning(paste("The variables (or variable with levels)", bad.var, "are perfectly collinear with another variable in the data.\n"))
}
}
}
return(list(m=m,priors=priors))
}
amcheck(data)
amcheck(data[,-1],noms = colnames(data[,-1])[ifelse(col_type[-1]=='factor',T,F)],parallel = 'multicore',incheck = T,empri = 0,m = 1)
amcheck(data[,-1],noms = colnames(data[,-1])[ifelse(col_type[-1]=='factor',T,F)],empri = 0,m = 1)
amcheck(data[,-1],noms = colnames(data[,-1])[ifelse(col_type[-1]=='factor',T,F)])
amcheck(data[,-1])
col_type <- 1 :34
for ( i in col_type){
col_type[i] <- class(data[,i])
}
amcheck(data[,-1],noms=colnames(data[,-1])[ifelse(col_type[-1]=='factor',T,F)])
amcheck(data[,-1],noms=colnames(data[,-1])[ifelse(col_type[-1]=='factor',T,F)])
colnames(data[,-1])[ifelse(col_type[-1]=='factor',T,F)]
w<- colnames(data[,-1])[ifelse(col_type[-1]=='factor',T,F)]
amcheck(data[,-1],noms=w)
amcheck(data[,-1],noms=w)
c <- capture.output(amelia(data[,-1],noms = w,parallel = 'multicore',incheck = T,empri = 0,m = 1))
library(Amelia)
amcheck(data[,-1],noms=w)
c <- capture.output(amelia(data[,-1],noms = w,parallel = 'multicore',incheck = T,empri = 0,m = 1))
?amelia
library(devtools)
document()
