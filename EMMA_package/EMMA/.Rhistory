parallel = self$param_set$values$parallel,turn_off_parallel = self$param_set$values$turn_off_parallel,
col_0_1 = self$param_set$values$col_0_1,optimize = self$param_set$values$optimize,
ntree = self$param_set$values$ntree,mtry = self$param_set$values$mtry,
maxiter=self$param_set$values$maxiter,maxnodes=self$param_set$values$maxnodes)
data_imputed <- cbind(data_imputed,target_col)
colnames(data_imputed)[ncol(data_imputed)] <- input[[1]]$target_names
if (input[[1]]$task_type=='classif'){
if (is.na(input[[1]]$positive)){
input[[1]] <- TaskClassif$new(input[[1]]$id,data_imputed,input[[1]]$target_names)}
else {input[[1]] <- TaskClassif$new(input[[1]]$id,data_imputed,input[[1]]$target_names,positive = input[[1]]$positive)}
}
if ( input[[1]]$task_type=='regr'){
input[[1]] <- TaskRegrf$new(input[[1]]$id,data_imputed,input[[1]]$target_names)
}
return(input)
},
predict_internal = function(input) {
data_to_impute <- as.data.frame(input[[1]]$data())
target_col <- data_to_impute[,input[[1]]$target_names]
data_to_impute <- data_to_impute[,ifelse(colnames(data_to_impute)==input[[1]]$target_names,FALSE,TRUE)]
# prepering arguments for function
col_type <- 1:ncol(data_to_impute)
for (i in col_type){
col_type[i] <- class(data_to_impute[,i])
}
percent_of_missing <- 1:ncol(data_to_impute)
for (i in percent_of_missing){
percent_of_missing[i] <- (sum(is.na(data_to_impute[,i]))/length(data_to_impute[,1]))*100
}
col_miss <- colnames(data_to_impute)[percent_of_missing>0]
col_no_miss <- colnames(data_to_impute)[percent_of_missing==0]
data_imputed <- autotune_missForest(data_to_impute,percent_of_missing = percent_of_missing,cores = self$param_set$values$cores,
ntree_set = self$param_set$values$ntree_set,mtry_set = self$param_set$values$mtry_set,
parallel = self$param_set$values$parallel,turn_off_parallel = self$param_set$values$turn_off_parallel,
col_0_1 = self$param_set$values$col_0_1,optimize = self$param_set$values$optimize,
ntree = self$param_set$values$ntree,mtry = self$param_set$values$mtry,
maxiter=self$param_set$values$maxiter,maxnodes=self$param_set$values$maxnodes)
data_imputed <- cbind(data_imputed,target_col)
colnames(data_imputed)[ncol(data_imputed)] <- input[[1]]$target_names
if (input[[1]]$task_type=='classif'){
if (is.na(input[[1]]$positive)){
input[[1]] <- TaskClassif$new(input[[1]]$id,data_imputed,input[[1]]$target_names)}
else {input[[1]] <- TaskClassif$new(input[[1]]$id,data_imputed,input[[1]]$target_names,positive = input[[1]]$positive)}
}
if ( input[[1]]$task_type=='regr'){
input[[1]] <- TaskRegrf$new(input[[1]]$id,data_imputed,input[[1]]$target_names)
}
return(input)
}
)
)
mlr_pipeops$add('missForest_imputation',PipeOpmissForest)
as.data.table(mlr_pipeops)[, c("key", "input.num", "output.num", "packages")]
mlr_pipeops$add('missFor',PipeOpmissForest)
as.data.table(mlr_pipeops)
mlr_pipeops$add('missForest_imputation',PipeOpmissForest)
mlr_pipeops$add('imput_missForest',PipeOpmissForest)
as.data.table(mlr_pipeops)
PipeOpmissForest <-  R6::R6Class("imput_missForest",lock_objects=FALSE,
inherit = PipeOp,  # inherit from PipeOp
public = list(
initialize = function(id = "imput_missForest", cores=NULL,ntree_set=c(100,200,500,1000),mtry_set=NULL,parallel=TRUE,
turn_off_parallel=FALSE,col_0_1=FALSE,mtry=NULL,ntree=100,optimize=TRUE,maxiter=20,maxnodes=NULL
) {
super$initialize(id, param_vals = list(cores =cores,ntree_set =ntree_set,mtry_set=mtry_set,parallel=parallel,
turn_off_parallel=turn_off_parallel,col_0_1=col_0_1,mtry=mtry,ntree=ntree,optimize=optimize,
maxiter=maxiter,maxnodes=maxnodes),
param_set= ParamSet$new(list(
'ntree_set'=ParamUty$new('ntree_set', default = c(100,200,500,1000), tags = 'missForest'),
'cores'=ParamUty$new('cores',default = NULL,tags='missForest'),
'mtry_set'=ParamUty$new('mtry_set',default = NULL,tags='missForest'),
'parallel'=ParamLgl$new('parallel',default = TRUE,tags = 'missForest'),
'turn_off_parallel'=ParamLgl$new('turn_off_parallel',default = FALSE,tags='missForest'),
'col_0_1'=ParamLgl$new('col_0_1',default = F,tags='missForest'),
'mtry'=ParamUty$new('mtry',default = NULL,tags='missForest'),
'ntree'=ParamInt$new('ntree',lower = 10,upper = Inf,default = 100,tags='missForest'),
'optimize'=ParamLgl$new('optimize',default = TRUE,tags='missForest'),
'maxiter'=ParamInt$new('maxiter',lower = 5,upper = Inf,default = 20,tags='missForest'),
'maxnodes'=ParamUty$new('maxnodes',default = NULL,tags='missForest')
)),
# declare "input" and "output" during construction here
# training and prediction take task and return task with imputed data ;
input = data.table::data.table(name = "input",
train = "Task", predict = 'Task'),
output = data.table::data.table(name = "output",
train = "Task", predict = "Task")
)
},
# PipeOp deriving classes must implement train_internal and
# predict_internal; each taking an input list and returning
# a list as output.
train_internal = function(input) {
data_to_impute <- as.data.frame(input[[1]]$data())
target_col <- data_to_impute[,input[[1]]$target_names]
data_to_impute <- data_to_impute[,ifelse(colnames(data_to_impute)==input[[1]]$target_names,FALSE,TRUE)]
# prepering arguments for function
col_type <- 1:ncol(data_to_impute)
for (i in col_type){
col_type[i] <- class(data_to_impute[,i])
}
percent_of_missing <- 1:ncol(data_to_impute)
for (i in percent_of_missing){
percent_of_missing[i] <- (sum(is.na(data_to_impute[,i]))/length(data_to_impute[,1]))*100
}
data_imputed <- autotune_missForest(data_to_impute,percent_of_missing = percent_of_missing,cores = self$param_set$values$cores,
ntree_set = self$param_set$values$ntree_set,mtry_set = self$param_set$values$mtry_set,
parallel = self$param_set$values$parallel,turn_off_parallel = self$param_set$values$turn_off_parallel,
col_0_1 = self$param_set$values$col_0_1,optimize = self$param_set$values$optimize,
ntree = self$param_set$values$ntree,mtry = self$param_set$values$mtry,
maxiter=self$param_set$values$maxiter,maxnodes=self$param_set$values$maxnodes)
data_imputed <- cbind(data_imputed,target_col)
colnames(data_imputed)[ncol(data_imputed)] <- input[[1]]$target_names
if (input[[1]]$task_type=='classif'){
if (is.na(input[[1]]$positive)){
input[[1]] <- TaskClassif$new(input[[1]]$id,data_imputed,input[[1]]$target_names)}
else {input[[1]] <- TaskClassif$new(input[[1]]$id,data_imputed,input[[1]]$target_names,positive = input[[1]]$positive)}
}
if ( input[[1]]$task_type=='regr'){
input[[1]] <- TaskRegrf$new(input[[1]]$id,data_imputed,input[[1]]$target_names)
}
return(input)
},
predict_internal = function(input) {
data_to_impute <- as.data.frame(input[[1]]$data())
target_col <- data_to_impute[,input[[1]]$target_names]
data_to_impute <- data_to_impute[,ifelse(colnames(data_to_impute)==input[[1]]$target_names,FALSE,TRUE)]
# prepering arguments for function
col_type <- 1:ncol(data_to_impute)
for (i in col_type){
col_type[i] <- class(data_to_impute[,i])
}
percent_of_missing <- 1:ncol(data_to_impute)
for (i in percent_of_missing){
percent_of_missing[i] <- (sum(is.na(data_to_impute[,i]))/length(data_to_impute[,1]))*100
}
col_miss <- colnames(data_to_impute)[percent_of_missing>0]
col_no_miss <- colnames(data_to_impute)[percent_of_missing==0]
data_imputed <- autotune_missForest(data_to_impute,percent_of_missing = percent_of_missing,cores = self$param_set$values$cores,
ntree_set = self$param_set$values$ntree_set,mtry_set = self$param_set$values$mtry_set,
parallel = self$param_set$values$parallel,turn_off_parallel = self$param_set$values$turn_off_parallel,
col_0_1 = self$param_set$values$col_0_1,optimize = self$param_set$values$optimize,
ntree = self$param_set$values$ntree,mtry = self$param_set$values$mtry,
maxiter=self$param_set$values$maxiter,maxnodes=self$param_set$values$maxnodes)
data_imputed <- cbind(data_imputed,target_col)
colnames(data_imputed)[ncol(data_imputed)] <- input[[1]]$target_names
if (input[[1]]$task_type=='classif'){
if (is.na(input[[1]]$positive)){
input[[1]] <- TaskClassif$new(input[[1]]$id,data_imputed,input[[1]]$target_names)}
else {input[[1]] <- TaskClassif$new(input[[1]]$id,data_imputed,input[[1]]$target_names,positive = input[[1]]$positive)}
}
if ( input[[1]]$task_type=='regr'){
input[[1]] <- TaskRegrf$new(input[[1]]$id,data_imputed,input[[1]]$target_names)
}
return(input)
}
)
)
mlr_pipeops$add('imput_missForest',PipeOpmissForest)
as.data.table(mlr_pipeops)
browser()
browser(as.data.table(mlr_pipeops))
mlr_pipeops$add('imput_missForest',PipeOpmissForest)
as.data.table(mlr_pipeops)
source('~/Pulpit/Job_repo/EMMA/EMMA_package/EMMA/R/PipeOPmissForest.R', echo=TRUE)
mlr_pipeops$add("mice_imputation", PipeOpMice)
mlr_pipeops$add("Amelia_imputation", PipeOpAmelia)
mlr_pipeops$add("missMDA_MCA_PCA_FMAD_imputation", PipeOpMissMDA_PCA_MCA_FMAD)
mlr_pipeops$add("missMDA_MFAimputation", PipeOpMissMDA_MFA)
library(devtools)
document()
.cores
?option
getOption(.cores)
getOption('.cores')
getOption('mc.cores')
mc.cores
options(mc.cores)
options('mc.cores')
options('mc.cores')
options('.cores')
getDoParWorkers()
options('cores')
library(parallel)
detectCores()
PipeOpmissForest <-  R6::R6Class("missForest_imputation",lock_objects=FALSE,
inherit = PipeOp,  # inherit from PipeOp
public = list(
initialize = function(id = "imput_missForest", cores=NULL,ntree_set=c(100,200,500,1000),mtry_set=NULL,parallel=TRUE
,col_0_1=FALSE,mtry=NULL,ntree=100,optimize=TRUE,maxiter=20,maxnodes=NULL
) {
super$initialize(id, param_vals = list(cores =cores,ntree_set =ntree_set,mtry_set=mtry_set,parallel=parallel,
turn_off_parallel=turn_off_parallel,col_0_1=col_0_1,mtry=mtry,ntree=ntree,optimize=optimize,
maxiter=maxiter,maxnodes=maxnodes),
param_set= ParamSet$new(list(
'ntree_set'=ParamUty$new('ntree_set', default = c(100,200,500,1000), tags = 'missForest'),
'cores'=ParamUty$new('cores',default = NULL,tags='missForest'),
'mtry_set'=ParamUty$new('mtry_set',default = NULL,tags='missForest'),
'parallel'=ParamLgl$new('parallel',default = TRUE,tags = 'missForest'),
'col_0_1'=ParamLgl$new('col_0_1',default = F,tags='missForest'),
'mtry'=ParamUty$new('mtry',default = NULL,tags='missForest'),
'ntree'=ParamInt$new('ntree',lower = 10,upper = Inf,default = 100,tags='missForest'),
'optimize'=ParamLgl$new('optimize',default = TRUE,tags='missForest'),
'maxiter'=ParamInt$new('maxiter',lower = 5,upper = Inf,default = 20,tags='missForest'),
'maxnodes'=ParamUty$new('maxnodes',default = NULL,tags='missForest')
)),
# declare "input" and "output" during construction here
# training and prediction take task and return task with imputed data ;
input = data.table::data.table(name = "input",
train = "Task", predict = 'Task'),
output = data.table::data.table(name = "output",
train = "Task", predict = "Task")
)
},
# PipeOp deriving classes must implement train_internal and
# predict_internal; each taking an input list and returning
# a list as output.
train_internal = function(input) {
data_to_impute <- as.data.frame(input[[1]]$data())
target_col <- data_to_impute[,input[[1]]$target_names]
data_to_impute <- data_to_impute[,ifelse(colnames(data_to_impute)==input[[1]]$target_names,FALSE,TRUE)]
# prepering arguments for function
col_type <- 1:ncol(data_to_impute)
for (i in col_type){
col_type[i] <- class(data_to_impute[,i])
}
percent_of_missing <- 1:ncol(data_to_impute)
for (i in percent_of_missing){
percent_of_missing[i] <- (sum(is.na(data_to_impute[,i]))/length(data_to_impute[,1]))*100
}
data_imputed <- autotune_missForest(data_to_impute,percent_of_missing = percent_of_missing,cores = self$param_set$values$cores,
ntree_set = self$param_set$values$ntree_set,mtry_set = self$param_set$values$mtry_set,
parallel = self$param_set$values$parallel,
col_0_1 = self$param_set$values$col_0_1,optimize = self$param_set$values$optimize,
ntree = self$param_set$values$ntree,mtry = self$param_set$values$mtry,
maxiter=self$param_set$values$maxiter,maxnodes=self$param_set$values$maxnodes)
data_imputed <- cbind(data_imputed,target_col)
colnames(data_imputed)[ncol(data_imputed)] <- input[[1]]$target_names
if (input[[1]]$task_type=='classif'){
if (is.na(input[[1]]$positive)){
input[[1]] <- TaskClassif$new(input[[1]]$id,data_imputed,input[[1]]$target_names)}
else {input[[1]] <- TaskClassif$new(input[[1]]$id,data_imputed,input[[1]]$target_names,positive = input[[1]]$positive)}
}
if ( input[[1]]$task_type=='regr'){
input[[1]] <- TaskRegrf$new(input[[1]]$id,data_imputed,input[[1]]$target_names)
}
return(input)
},
predict_internal = function(input) {
data_to_impute <- as.data.frame(input[[1]]$data())
target_col <- data_to_impute[,input[[1]]$target_names]
data_to_impute <- data_to_impute[,ifelse(colnames(data_to_impute)==input[[1]]$target_names,FALSE,TRUE)]
# prepering arguments for function
col_type <- 1:ncol(data_to_impute)
for (i in col_type){
col_type[i] <- class(data_to_impute[,i])
}
percent_of_missing <- 1:ncol(data_to_impute)
for (i in percent_of_missing){
percent_of_missing[i] <- (sum(is.na(data_to_impute[,i]))/length(data_to_impute[,1]))*100
}
col_miss <- colnames(data_to_impute)[percent_of_missing>0]
col_no_miss <- colnames(data_to_impute)[percent_of_missing==0]
data_imputed <- autotune_missForest(data_to_impute,percent_of_missing = percent_of_missing,cores = self$param_set$values$cores,
ntree_set = self$param_set$values$ntree_set,mtry_set = self$param_set$values$mtry_set,
parallel = self$param_set$values$parallel,col_0_1 = self$param_set$values$col_0_1,optimize = self$param_set$values$optimize,
ntree = self$param_set$values$ntree,mtry = self$param_set$values$mtry,
maxiter=self$param_set$values$maxiter,maxnodes=self$param_set$values$maxnodes)
data_imputed <- cbind(data_imputed,target_col)
colnames(data_imputed)[ncol(data_imputed)] <- input[[1]]$target_names
if (input[[1]]$task_type=='classif'){
if (is.na(input[[1]]$positive)){
input[[1]] <- TaskClassif$new(input[[1]]$id,data_imputed,input[[1]]$target_names)}
else {input[[1]] <- TaskClassif$new(input[[1]]$id,data_imputed,input[[1]]$target_names,positive = input[[1]]$positive)}
}
if ( input[[1]]$task_type=='regr'){
input[[1]] <- TaskRegrf$new(input[[1]]$id,data_imputed,input[[1]]$target_names)
}
return(input)
}
)
)
mlr_pipeops$add("missForest_imputation", PipeOpmissForest)
id <- 51
df_oml <- getOMLDataSet(id)
df_desc <- df_oml$desc
df <- df_oml$data
### Preprocessing step ###
#Columns to ignore according to tags
to_ignore <- df_desc$ignore.attribute
if(!is.na(to_ignore)){
df <- select(df, -all_of(to_ignore))
}
#Removing row ID column according to tags
row_id <- df_desc$row.id.attribute
if(!is.na(row_id)){
df <- select(df, -all_of(row_id))
}
#Data types
data_types_check <- sapply(df, check_type)
if(any(!data_types_check)){
wrong_columns <- colnames(df)[!data_types_check]
#Trying possible conversions
for(col in wrong_columns){
if(is.logical(df[,col]) | is.character(df[,col])){
df[,col] <- as.factor(df[,col])
}else{
warning(paste("Data type trouble ID: ", as.character(id)))
data_types_troubles <- c(data_types_troubles, id)
}
}
}
#Removing possible duplicate rows
df <- df[!duplicated(df), ]
#Removing constant columns
df <- remove_constant(df)
#Removing empty columns
df <- remove_empty(df, "cols")
#All to lowercase
df <- mutate_if(df, is.factor, function(x) factor(tolower(x)))
#Missing values in target variable
target <- df_oml$target.features
if(any(is.na(df[, target]))){
miss_in_target <- c(miss_in_target, id)
warning(paste("Missing values in target variable ID: ", as.character(id)))
}
require(EMMA)
library(OpenML)
library(readr)
library(dplyr)
library(janitor)
library(tidyselect)
library(doParallel)
id <- 51
df_oml <- getOMLDataSet(id)
df_desc <- df_oml$desc
df <- df_oml$data
### Preprocessing step ###
#Columns to ignore according to tags
to_ignore <- df_desc$ignore.attribute
if(!is.na(to_ignore)){
df <- select(df, -all_of(to_ignore))
}
#Removing row ID column according to tags
row_id <- df_desc$row.id.attribute
if(!is.na(row_id)){
df <- select(df, -all_of(row_id))
}
#Data types
data_types_check <- sapply(df, check_type)
if(any(!data_types_check)){
wrong_columns <- colnames(df)[!data_types_check]
#Trying possible conversions
for(col in wrong_columns){
if(is.logical(df[,col]) | is.character(df[,col])){
df[,col] <- as.factor(df[,col])
}else{
warning(paste("Data type trouble ID: ", as.character(id)))
data_types_troubles <- c(data_types_troubles, id)
}
}
}
#Removing possible duplicate rows
df <- df[!duplicated(df), ]
#Removing constant columns
df <- remove_constant(df)
#Removing empty columns
df <- remove_empty(df, "cols")
#All to lowercase
df <- mutate_if(df, is.factor, function(x) factor(tolower(x)))
#Missing values in target variable
target <- df_oml$target.features
if(any(is.na(df[, target]))){
miss_in_target <- c(miss_in_target, id)
warning(paste("Missing values in target variable ID: ", as.character(id)))
}
View(df)
id <- 52
df_oml <- getOMLDataSet(id)
df_desc <- df_oml$desc
df <- df_oml$data
### Preprocessing step ###
#Columns to ignore according to tags
to_ignore <- df_desc$ignore.attribute
if(!is.na(to_ignore)){
df <- select(df, -all_of(to_ignore))
}
#Removing row ID column according to tags
row_id <- df_desc$row.id.attribute
if(!is.na(row_id)){
df <- select(df, -all_of(row_id))
}
#Data types
data_types_check <- sapply(df, check_type)
if(any(!data_types_check)){
wrong_columns <- colnames(df)[!data_types_check]
#Trying possible conversions
for(col in wrong_columns){
if(is.logical(df[,col]) | is.character(df[,col])){
df[,col] <- as.factor(df[,col])
}else{
warning(paste("Data type trouble ID: ", as.character(id)))
data_types_troubles <- c(data_types_troubles, id)
}
}
}
#Removing possible duplicate rows
df <- df[!duplicated(df), ]
#Removing constant columns
df <- remove_constant(df)
#Removing empty columns
df <- remove_empty(df, "cols")
#All to lowercase
df <- mutate_if(df, is.factor, function(x) factor(tolower(x)))
#Missing values in target variable
target <- df_oml$target.features
if(any(is.na(df[, target]))){
miss_in_target <- c(miss_in_target, id)
warning(paste("Missing values in target variable ID: ", as.character(id)))
}
View(df)
document()
library(EMMA)
?autotune_missForest
#' @param ntree ntree from missForest function
#' @param mtry mtry form missforest function
#' @param verbose If FALSE funtion didn't print on console.
#' @param maxiter maxiter form missForest function.
#' @param maxnodes maxnodes from missForest function.
#' @import missForest
#' @import doParallel
#' @param col_0_1 decide if add bonus column informing where imputation been done. 0 - value was in dataset, 1 - value was imputed. Default False.
#'
#' @return Return data.frame with imputed values.
autotune_missForest <-function(df,percent_of_missing,cores=NULL,ntree_set =c(100,200,500,1000),mtry_set=NULL,parallel=TRUE,turn_off_parallel=FALSE,col_0_1=FALSE,
optimize=TRUE,ntree=100,mtry=NULL,verbose=FALSE,maxiter=20,maxnodes=NULL){
# Checking if parallel backed is runing and starting it if not
if (parallel){
veribles = ncol(df)
if (ceiling(detectCores()/2)>=veribles){cores <- (veribles-2)}
registerDoParallel(cores = cores)
}
# Prepering mtry_set if not given
if (is.null(mtry_set)){
mtry_set <- 1:4
mtry_set[1] <- floor(sqrt(ncol(df)))
if (mtry_set[1]>1){
mtry_set[2] <- ceiling(mtry_set[1]/2)
vector <- (mtry_set[1]:ncol(df))
mtry_set[3] <- floor(length(vector)/3)
mtry_set[4] <- floor(2*length(vector)/3)
}
else{
vector <- (mtry_set[1]:ncol(df))
mtry_set[2] <- flor(length(vector)/4)
mtry_set[3] <- floor(2*length(vector)/4)
mtry_set[4] <- floor(3*length(vector)/4)
}
}
if (optimize){
# If parallel=TRUE
parallelize <- 'no'
if (parallel){
parallelize <-  'variables'}
# Grid search using mean OBBerror
best_params <-  c(-11,-11)
best_OBB <- 10
for (i in ntree_set)
{
for (j in mtry_set){
skip_to_next <- FALSE
tryCatch({
iteration <-  mean(missForest(df,maxiter = maxiter,ntree = i,mtry = j,parallelize=parallelize,maxnodes = maxnodes,verbose = verbose)$OOBerror)
if (iteration<best_OBB){
best_OBB <- iteration
best_params[1] <- i
best_params[2] <- j
}
}, error = function(e) { skip_to_next <<- TRUE})
if(skip_to_next) { next }
}
}
#fianl imputation
final <- missForest(df,maxiter = maxiter,maxnodes = maxnodes,ntree = best_params[1],mtry = best_params[2],parallelize=parallelize,verbose = verbose)$ximp
}
if (!optimize){
if (is.null(mtry)){
final <- missForest(df,maxiter = maxiter,ntree = ntree,maxnodes = maxnodes,mtry = floor(sqrt(ncol(df))),parallelize = parallelize,verbose = verbose)$ximp}
else{ final <- missForest(df,maxiter = maxiter,ntree = ntree,maxnodes = maxnodes,mtry = mtry,parallelize = parallelize,verbose = verbose)$ximp}
}
#adding 0_1_cols
if (col_0_1){
columns_with_missing <-  (as.data.frame(is.na(df))*1)[,percent_of_missing>0]
colnames(columns_with_missing) <- paste(colnames(columns_with_missing),'where',sep='_')
final <- cbind(final,columns_with_missing)
}
# turn off paralllel
if (parallel){
registerDoSEQ()
}
return(final)
}
?autotune_missForest
document()
load_all()
document()
library(EMMA)
?autotune_missForest
?autotune_missForest
?PipeOpmissForest
?autotune_missForest
library(EMMA)
?autotune_missForest
